<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Chapter 2 A Single Heatmap | ComplexHeatmap Complete Reference</title>
  <meta name="description" content="Complex heatmaps are efficient to visualize associations between different sources of data sets and reveal potential patterns. Here the ComplexHeatmap R package provides a highly flexible way to arrange multiple heatmaps and supports various annotation graphics. This book is the complete reference to ComplexHeatmap pacakge.">
  <meta name="generator" content="bookdown  and GitBook 2.6.7">

  <meta property="og:title" content="Chapter 2 A Single Heatmap | ComplexHeatmap Complete Reference" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://jokergoo.github.io/ComplexHeatmap-reference/book" />
  <meta property="og:image" content="https://jokergoo.github.io/ComplexHeatmap-reference/bookcomplexheatmap-cover.jpg" />
  <meta property="og:description" content="Complex heatmaps are efficient to visualize associations between different sources of data sets and reveal potential patterns. Here the ComplexHeatmap R package provides a highly flexible way to arrange multiple heatmaps and supports various annotation graphics. This book is the complete reference to ComplexHeatmap pacakge." />
  <meta name="github-repo" content="jokergoo/ComplexHeatmap-reference" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 2 A Single Heatmap | ComplexHeatmap Complete Reference" />
  
  <meta name="twitter:description" content="Complex heatmaps are efficient to visualize associations between different sources of data sets and reveal potential patterns. Here the ComplexHeatmap R package provides a highly flexible way to arrange multiple heatmaps and supports various annotation graphics. This book is the complete reference to ComplexHeatmap pacakge." />
  <meta name="twitter:image" content="https://jokergoo.github.io/ComplexHeatmap-reference/bookcomplexheatmap-cover.jpg" />

<meta name="author" content="Zuguang Gu">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="introduction.html">
<link rel="next" href="heatmap-annotations.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">ComplexHeatmap Complete Reference</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>About</a></li>
<li class="chapter" data-level="1" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="introduction.html"><a href="introduction.html#general-design"><i class="fa fa-check"></i><b>1.1</b> General design</a></li>
<li class="chapter" data-level="1.2" data-path="introduction.html"><a href="introduction.html#a-brief-description-of-following-chapters"><i class="fa fa-check"></i><b>1.2</b> A brief description of following chapters</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html"><i class="fa fa-check"></i><b>2</b> A Single Heatmap</a><ul>
<li class="chapter" data-level="2.1" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#colors"><i class="fa fa-check"></i><b>2.1</b> Colors</a></li>
<li class="chapter" data-level="2.2" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#heatmap-titles"><i class="fa fa-check"></i><b>2.2</b> Titles</a></li>
<li class="chapter" data-level="2.3" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#clustering"><i class="fa fa-check"></i><b>2.3</b> Clustering</a><ul>
<li class="chapter" data-level="2.3.1" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#distance-methods"><i class="fa fa-check"></i><b>2.3.1</b> Distance methods</a></li>
<li class="chapter" data-level="2.3.2" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#clustering-methods"><i class="fa fa-check"></i><b>2.3.2</b> Clustering methods</a></li>
<li class="chapter" data-level="2.3.3" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#render-dendrograms"><i class="fa fa-check"></i><b>2.3.3</b> Render dendrograms</a></li>
<li class="chapter" data-level="2.3.4" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#reorder-dendrograms"><i class="fa fa-check"></i><b>2.3.4</b> Reorder dendrograms</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#row-and_column_orders"><i class="fa fa-check"></i><b>2.4</b> Set row and column orders</a></li>
<li class="chapter" data-level="2.5" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#heatmap-seriation"><i class="fa fa-check"></i><b>2.5</b> Seriation</a></li>
<li class="chapter" data-level="2.6" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#dimension-names"><i class="fa fa-check"></i><b>2.6</b> Dimension names</a></li>
<li class="chapter" data-level="2.7" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#heatmap-split"><i class="fa fa-check"></i><b>2.7</b> Heatmap split</a><ul>
<li class="chapter" data-level="2.7.1" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#split-by-kmeans-clustering"><i class="fa fa-check"></i><b>2.7.1</b> Split by k-means clustering</a></li>
<li class="chapter" data-level="2.7.2" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#split-by-categorical-variables"><i class="fa fa-check"></i><b>2.7.2</b> Split by categorical variables</a></li>
<li class="chapter" data-level="2.7.3" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#spilt-by-dendrogram"><i class="fa fa-check"></i><b>2.7.3</b> Split by dendrogram</a></li>
<li class="chapter" data-level="2.7.4" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#order-of-slices"><i class="fa fa-check"></i><b>2.7.4</b> Order of slices</a></li>
<li class="chapter" data-level="2.7.5" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#titles-for-splitting"><i class="fa fa-check"></i><b>2.7.5</b> Titles for splitting</a></li>
<li class="chapter" data-level="2.7.6" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#graphic-parameters-for-splitting"><i class="fa fa-check"></i><b>2.7.6</b> Graphic parameters for splitting</a></li>
<li class="chapter" data-level="2.7.7" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#gaps-between-slices"><i class="fa fa-check"></i><b>2.7.7</b> Gaps between slices</a></li>
<li class="chapter" data-level="2.7.8" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#split-heatmap-annotations"><i class="fa fa-check"></i><b>2.7.8</b> Split heatmap annotations</a></li>
</ul></li>
<li class="chapter" data-level="2.8" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#heatmap-as-raster-image"><i class="fa fa-check"></i><b>2.8</b> Heatmap as raster image</a></li>
<li class="chapter" data-level="2.9" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#customize-the-heatmap-body"><i class="fa fa-check"></i><b>2.9</b> Customize the heatmap body</a><ul>
<li class="chapter" data-level="2.9.1" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#cell-fun"><i class="fa fa-check"></i><b>2.9.1</b> cell_fun</a></li>
<li class="chapter" data-level="2.9.2" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#layer-fun"><i class="fa fa-check"></i><b>2.9.2</b> layer_fun</a></li>
</ul></li>
<li class="chapter" data-level="2.10" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#size-of-the-heatmap"><i class="fa fa-check"></i><b>2.10</b> Size of the heatmap</a></li>
<li class="chapter" data-level="2.11" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#plot-the-heatmap"><i class="fa fa-check"></i><b>2.11</b> Plot the heatmap</a></li>
<li class="chapter" data-level="2.12" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#get-orders-and-dendrograms-from-heatmap"><i class="fa fa-check"></i><b>2.12</b> Get orders and dendrograms</a></li>
<li class="chapter" data-level="2.13" data-path="a-single-heatmap.html"><a href="a-single-heatmap.html#subset-a-heatmap"><i class="fa fa-check"></i><b>2.13</b> Subset a heatmap</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html"><i class="fa fa-check"></i><b>3</b> Heatmap Annotations</a><ul>
<li class="chapter" data-level="3.1" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#simple-annotation"><i class="fa fa-check"></i><b>3.1</b> Simple annotation</a></li>
<li class="chapter" data-level="3.2" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#simple-annotation-as-an-annotation-function"><i class="fa fa-check"></i><b>3.2</b> Simple annotation as an annotation function</a></li>
<li class="chapter" data-level="3.3" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#empty-annotation"><i class="fa fa-check"></i><b>3.3</b> Empty annotation</a></li>
<li class="chapter" data-level="3.4" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#block-annotation"><i class="fa fa-check"></i><b>3.4</b> Block annotation</a></li>
<li class="chapter" data-level="3.5" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#image-annotation"><i class="fa fa-check"></i><b>3.5</b> Image annotation</a></li>
<li class="chapter" data-level="3.6" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#points-annotation"><i class="fa fa-check"></i><b>3.6</b> Points annotation</a></li>
<li class="chapter" data-level="3.7" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#lines-annotation"><i class="fa fa-check"></i><b>3.7</b> Lines annotation</a></li>
<li class="chapter" data-level="3.8" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#barplot_annotation"><i class="fa fa-check"></i><b>3.8</b> Barplot annotation</a></li>
<li class="chapter" data-level="3.9" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#box-annotation"><i class="fa fa-check"></i><b>3.9</b> Boxplot annotation</a></li>
<li class="chapter" data-level="3.10" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#histogram-annotation"><i class="fa fa-check"></i><b>3.10</b> Histogram annotation</a></li>
<li class="chapter" data-level="3.11" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#density-annotation"><i class="fa fa-check"></i><b>3.11</b> Density annotation</a></li>
<li class="chapter" data-level="3.12" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#joyplot-annotation"><i class="fa fa-check"></i><b>3.12</b> Joyplot annotation</a></li>
<li class="chapter" data-level="3.13" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#horizon-chart-annotation"><i class="fa fa-check"></i><b>3.13</b> Horizon chart annotation</a></li>
<li class="chapter" data-level="3.14" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#text-annotation"><i class="fa fa-check"></i><b>3.14</b> Text annotation</a></li>
<li class="chapter" data-level="3.15" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#mark-annotation"><i class="fa fa-check"></i><b>3.15</b> Mark annotation</a></li>
<li class="chapter" data-level="3.16" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#summary-annotation"><i class="fa fa-check"></i><b>3.16</b> Summary annotation</a></li>
<li class="chapter" data-level="3.17" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#zoom-annotation"><i class="fa fa-check"></i><b>3.17</b> Zoom annotation</a></li>
<li class="chapter" data-level="3.18" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#multiple-annotations"><i class="fa fa-check"></i><b>3.18</b> Multiple annotations</a><ul>
<li class="chapter" data-level="3.18.1" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#size-of-annotations"><i class="fa fa-check"></i><b>3.18.1</b> Size of annotations</a></li>
</ul></li>
<li class="chapter" data-level="3.19" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#heatmap-annotation-utility-function"><i class="fa fa-check"></i><b>3.19</b> Utility functions</a></li>
<li class="chapter" data-level="3.20" data-path="heatmap-annotations.html"><a href="heatmap-annotations.html#implement-new-annotation-functions"><i class="fa fa-check"></i><b>3.20</b> Implement new annotation functions</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html"><i class="fa fa-check"></i><b>4</b> A List of Heatmaps</a><ul>
<li class="chapter" data-level="4.1" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#heatmap-list-titles"><i class="fa fa-check"></i><b>4.1</b> Titles</a></li>
<li class="chapter" data-level="4.2" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#size-of-heatmaps"><i class="fa fa-check"></i><b>4.2</b> Size of heatmaps</a></li>
<li class="chapter" data-level="4.3" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#gap-between-heatmaps"><i class="fa fa-check"></i><b>4.3</b> Gap between heatmaps</a></li>
<li class="chapter" data-level="4.4" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#automatic-adjustment-to-the-main-heatmap"><i class="fa fa-check"></i><b>4.4</b> Automatic adjustment to the main heatmap</a></li>
<li class="chapter" data-level="4.5" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#control-main-heatmap-in-draw-function"><i class="fa fa-check"></i><b>4.5</b> Control main heatmap in draw() function</a></li>
<li class="chapter" data-level="4.6" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#annotations-as-components-are-adjusted"><i class="fa fa-check"></i><b>4.6</b> Annotations as components are adjusted</a></li>
<li class="chapter" data-level="4.7" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#concatenate-with-annotations"><i class="fa fa-check"></i><b>4.7</b> Concatenate with annotations</a></li>
<li class="chapter" data-level="4.8" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#concatenate-only-the-annotations"><i class="fa fa-check"></i><b>4.8</b> Concatenate only the annotations</a></li>
<li class="chapter" data-level="4.9" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#vertical-concatenation"><i class="fa fa-check"></i><b>4.9</b> Vertical concatenation</a></li>
<li class="chapter" data-level="4.10" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#subset-heatmap-list"><i class="fa fa-check"></i><b>4.10</b> Subset the heatmap list</a></li>
<li class="chapter" data-level="4.11" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#plot-the-heamtap-list"><i class="fa fa-check"></i><b>4.11</b> Plot the heatmap list</a></li>
<li class="chapter" data-level="4.12" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#get-orders-and-dendrograms-from-a-list-of-heatmaps"><i class="fa fa-check"></i><b>4.12</b> Get orders and dendrograms</a></li>
<li class="chapter" data-level="4.13" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#change-parameters-globally"><i class="fa fa-check"></i><b>4.13</b> Change parameters globally</a></li>
<li class="chapter" data-level="4.14" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#adjust-blank-space-caused-by-annotations"><i class="fa fa-check"></i><b>4.14</b> Adjust blank space caused by annotations</a></li>
<li class="chapter" data-level="4.15" data-path="a-list-of-heatmaps.html"><a href="a-list-of-heatmaps.html#manually-increase-space-around-the-plot"><i class="fa fa-check"></i><b>4.15</b> Manually increase space around the plot</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="legends.html"><a href="legends.html"><i class="fa fa-check"></i><b>5</b> Legends</a><ul>
<li class="chapter" data-level="5.1" data-path="legends.html"><a href="legends.html#continuous-legends"><i class="fa fa-check"></i><b>5.1</b> Continuous legends</a></li>
<li class="chapter" data-level="5.2" data-path="legends.html"><a href="legends.html#discrete-legends"><i class="fa fa-check"></i><b>5.2</b> Discrete legends</a></li>
<li class="chapter" data-level="5.3" data-path="legends.html"><a href="legends.html#a-list-of-legends"><i class="fa fa-check"></i><b>5.3</b> A list of legends</a></li>
<li class="chapter" data-level="5.4" data-path="legends.html"><a href="legends.html#heatmap-and-annotation-legends"><i class="fa fa-check"></i><b>5.4</b> Heatmap and annotation legends</a></li>
<li class="chapter" data-level="5.5" data-path="legends.html"><a href="legends.html#add-customized-legends"><i class="fa fa-check"></i><b>5.5</b> Add customized legends</a></li>
<li class="chapter" data-level="5.6" data-path="legends.html"><a href="legends.html#the-side-of-legends"><i class="fa fa-check"></i><b>5.6</b> The side of legends</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="heatmap-decoration.html"><a href="heatmap-decoration.html"><i class="fa fa-check"></i><b>6</b> Heatmap Decoration</a><ul>
<li class="chapter" data-level="6.1" data-path="heatmap-decoration.html"><a href="heatmap-decoration.html#decoration-functions"><i class="fa fa-check"></i><b>6.1</b> Decoration functions</a></li>
<li class="chapter" data-level="6.2" data-path="heatmap-decoration.html"><a href="heatmap-decoration.html#decoration-examples"><i class="fa fa-check"></i><b>6.2</b> Examples</a><ul>
<li class="chapter" data-level="6.2.1" data-path="heatmap-decoration.html"><a href="heatmap-decoration.html#barplot-for-single-column-heatmap"><i class="fa fa-check"></i><b>6.2.1</b> Barplot for single-column heatmap</a></li>
<li class="chapter" data-level="6.2.2" data-path="heatmap-decoration.html"><a href="heatmap-decoration.html#add-titles-for-row-annotations"><i class="fa fa-check"></i><b>6.2.2</b> Add titles for row annotations</a></li>
<li class="chapter" data-level="6.2.3" data-path="heatmap-decoration.html"><a href="heatmap-decoration.html#other-possible-use-of-decorations"><i class="fa fa-check"></i><b>6.2.3</b> Other possible use of decorations</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="oncoprint.html"><a href="oncoprint.html"><i class="fa fa-check"></i><b>7</b> OncoPrint</a><ul>
<li class="chapter" data-level="7.1" data-path="oncoprint.html"><a href="oncoprint.html#oncoprint-general-settings"><i class="fa fa-check"></i><b>7.1</b> General settings</a><ul>
<li class="chapter" data-level="7.1.1" data-path="oncoprint.html"><a href="oncoprint.html#input-data-format"><i class="fa fa-check"></i><b>7.1.1</b> Input data format</a></li>
<li class="chapter" data-level="7.1.2" data-path="oncoprint.html"><a href="oncoprint.html#define-the-alter-fun"><i class="fa fa-check"></i><b>7.1.2</b> Define the alter_fun()</a></li>
<li class="chapter" data-level="7.1.3" data-path="oncoprint.html"><a href="oncoprint.html#oncoprint-background"><i class="fa fa-check"></i><b>7.1.3</b> Background</a></li>
<li class="chapter" data-level="7.1.4" data-path="oncoprint.html"><a href="oncoprint.html#complex-alteration-types"><i class="fa fa-check"></i><b>7.1.4</b> Complex alteration types</a></li>
<li class="chapter" data-level="7.1.5" data-path="oncoprint.html"><a href="oncoprint.html#other-heatmap-related-settings"><i class="fa fa-check"></i><b>7.1.5</b> Other heatmap-related settings</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="oncoprint.html"><a href="oncoprint.html#apply-to-cbioportal-dataset"><i class="fa fa-check"></i><b>7.2</b> Apply to cBioPortal dataset</a><ul>
<li class="chapter" data-level="7.2.1" data-path="oncoprint.html"><a href="oncoprint.html#remove-empty-rows-and-columns"><i class="fa fa-check"></i><b>7.2.1</b> Remove empty rows and columns</a></li>
<li class="chapter" data-level="7.2.2" data-path="oncoprint.html"><a href="oncoprint.html#reorder-the-oncoprint"><i class="fa fa-check"></i><b>7.2.2</b> Reorder the oncoPrint</a></li>
<li class="chapter" data-level="7.2.3" data-path="oncoprint.html"><a href="oncoprint.html#oncoprint-annotations"><i class="fa fa-check"></i><b>7.2.3</b> OncoPrint annotations</a></li>
<li class="chapter" data-level="7.2.4" data-path="oncoprint.html"><a href="oncoprint.html#oncoprint-as-a-heatmap"><i class="fa fa-check"></i><b>7.2.4</b> oncoPrint as a Heatmap</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="upset-plot.html"><a href="upset-plot.html"><i class="fa fa-check"></i><b>8</b> UpSet plot</a><ul>
<li class="chapter" data-level="8.1" data-path="upset-plot.html"><a href="upset-plot.html#input-data"><i class="fa fa-check"></i><b>8.1</b> Input data</a></li>
<li class="chapter" data-level="8.2" data-path="upset-plot.html"><a href="upset-plot.html#upset-mode"><i class="fa fa-check"></i><b>8.2</b> Mode</a></li>
<li class="chapter" data-level="8.3" data-path="upset-plot.html"><a href="upset-plot.html#make-the-combination-matrix"><i class="fa fa-check"></i><b>8.3</b> Make the combination matrix</a></li>
<li class="chapter" data-level="8.4" data-path="upset-plot.html"><a href="upset-plot.html#upset-utility-functions"><i class="fa fa-check"></i><b>8.4</b> Utility functions</a></li>
<li class="chapter" data-level="8.5" data-path="upset-plot.html"><a href="upset-plot.html#upset-making-the-plot"><i class="fa fa-check"></i><b>8.5</b> Make the plot</a></li>
<li class="chapter" data-level="8.6" data-path="upset-plot.html"><a href="upset-plot.html#upset-plots-as-heatmaps"><i class="fa fa-check"></i><b>8.6</b> UpSet plots as heatmaps</a></li>
<li class="chapter" data-level="8.7" data-path="upset-plot.html"><a href="upset-plot.html#example-with-the-movies-dataset"><i class="fa fa-check"></i><b>8.7</b> Example with the movies dataset</a></li>
<li class="chapter" data-level="8.8" data-path="upset-plot.html"><a href="upset-plot.html#example-with-the-genomic-regions"><i class="fa fa-check"></i><b>8.8</b> Example with the genomic regions</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="more-examples.html"><a href="more-examples.html"><i class="fa fa-check"></i><b>9</b> More Examples</a><ul>
<li class="chapter" data-level="9.1" data-path="more-examples.html"><a href="more-examples.html#add-more-information-for-gene-expression-matrix"><i class="fa fa-check"></i><b>9.1</b> Add more information for gene expression matrix</a></li>
<li class="chapter" data-level="9.2" data-path="more-examples.html"><a href="more-examples.html#the-measles-vaccine-heatmap"><i class="fa fa-check"></i><b>9.2</b> The measles vaccine heatmap</a></li>
<li class="chapter" data-level="9.3" data-path="more-examples.html"><a href="more-examples.html#visualize-cell-heterogeneity-from-single-cell-rnaseq"><i class="fa fa-check"></i><b>9.3</b> Visualize Cell Heterogeneity from Single Cell RNASeq</a></li>
<li class="chapter" data-level="9.4" data-path="more-examples.html"><a href="more-examples.html#correlations-between-methylation-expression-and-other-genomic-features"><i class="fa fa-check"></i><b>9.4</b> Correlations between methylation, expression and other genomic features</a></li>
<li class="chapter" data-level="9.5" data-path="more-examples.html"><a href="more-examples.html#visualize-methylation-profile-with-complex-annotations"><i class="fa fa-check"></i><b>9.5</b> Visualize Methylation Profile with Complex Annotations</a></li>
<li class="chapter" data-level="9.6" data-path="more-examples.html"><a href="more-examples.html#add-multiple-boxplots-for-single-row"><i class="fa fa-check"></i><b>9.6</b> Add multiple boxplots for single row</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="other-high-level-plots.html"><a href="other-high-level-plots.html"><i class="fa fa-check"></i><b>10</b> Other High-level Plots</a><ul>
<li class="chapter" data-level="10.1" data-path="other-high-level-plots.html"><a href="other-high-level-plots.html#density-heatmap"><i class="fa fa-check"></i><b>10.1</b> Density heatmap</a></li>
<li class="chapter" data-level="10.2" data-path="other-high-level-plots.html"><a href="other-high-level-plots.html#stacked-summary-plot"><i class="fa fa-check"></i><b>10.2</b> Stacked summary plot</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="other-tricks.html"><a href="other-tricks.html"><i class="fa fa-check"></i><b>11</b> Other Tricks</a><ul>
<li class="chapter" data-level="11.1" data-path="other-tricks.html"><a href="other-tricks.html#set-the-same-cell-size-for-different-heatmaps-with-different-dimensions"><i class="fa fa-check"></i><b>11.1</b> Set the same cell size for different heatmaps with different dimensions</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">ComplexHeatmap Complete Reference</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="a-single-heatmap" class="section level1">
<h1><span class="header-section-number">Chapter 2</span> A Single Heatmap</h1>
<p>A single heatmap is the most used approach for visualizing the data. Although “the shining point” of the <strong>ComplexHeatmap</strong> package is it can visualize a list of heatmaps in parallel, as the basic unit of the heatmap list, it is still very important to have the single heatmap nicely configured.</p>
<p>First let’s generate a random matrix where there are three groups by columns and three groups by rows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123</span>)
nr1 =<span class="st"> </span><span class="dv">4</span>; nr2 =<span class="st"> </span><span class="dv">8</span>; nr3 =<span class="st"> </span><span class="dv">6</span>; nr =<span class="st"> </span>nr1 <span class="op">+</span><span class="st"> </span>nr2 <span class="op">+</span><span class="st"> </span>nr3
nc1 =<span class="st"> </span><span class="dv">6</span>; nc2 =<span class="st"> </span><span class="dv">8</span>; nc3 =<span class="st"> </span><span class="dv">10</span>; nc =<span class="st"> </span>nc1 <span class="op">+</span><span class="st"> </span>nc2 <span class="op">+</span><span class="st"> </span>nc3
mat =<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rbind</span>(<span class="kw">matrix</span>(<span class="kw">rnorm</span>(nr1<span class="op">*</span>nc1, <span class="dt">mean =</span> <span class="dv">1</span>,   <span class="dt">sd =</span> <span class="fl">0.5</span>), <span class="dt">nr =</span> nr1),
          <span class="kw">matrix</span>(<span class="kw">rnorm</span>(nr2<span class="op">*</span>nc1, <span class="dt">mean =</span> <span class="dv">0</span>,   <span class="dt">sd =</span> <span class="fl">0.5</span>), <span class="dt">nr =</span> nr2),
          <span class="kw">matrix</span>(<span class="kw">rnorm</span>(nr3<span class="op">*</span>nc1, <span class="dt">mean =</span> <span class="dv">0</span>,   <span class="dt">sd =</span> <span class="fl">0.5</span>), <span class="dt">nr =</span> nr3)),
    <span class="kw">rbind</span>(<span class="kw">matrix</span>(<span class="kw">rnorm</span>(nr1<span class="op">*</span>nc2, <span class="dt">mean =</span> <span class="dv">0</span>,   <span class="dt">sd =</span> <span class="fl">0.5</span>), <span class="dt">nr =</span> nr1),
          <span class="kw">matrix</span>(<span class="kw">rnorm</span>(nr2<span class="op">*</span>nc2, <span class="dt">mean =</span> <span class="dv">1</span>,   <span class="dt">sd =</span> <span class="fl">0.5</span>), <span class="dt">nr =</span> nr2),
          <span class="kw">matrix</span>(<span class="kw">rnorm</span>(nr3<span class="op">*</span>nc2, <span class="dt">mean =</span> <span class="dv">0</span>,   <span class="dt">sd =</span> <span class="fl">0.5</span>), <span class="dt">nr =</span> nr3)),
    <span class="kw">rbind</span>(<span class="kw">matrix</span>(<span class="kw">rnorm</span>(nr1<span class="op">*</span>nc3, <span class="dt">mean =</span> <span class="fl">0.5</span>, <span class="dt">sd =</span> <span class="fl">0.5</span>), <span class="dt">nr =</span> nr1),
          <span class="kw">matrix</span>(<span class="kw">rnorm</span>(nr2<span class="op">*</span>nc3, <span class="dt">mean =</span> <span class="fl">0.5</span>, <span class="dt">sd =</span> <span class="fl">0.5</span>), <span class="dt">nr =</span> nr2),
          <span class="kw">matrix</span>(<span class="kw">rnorm</span>(nr3<span class="op">*</span>nc3, <span class="dt">mean =</span> <span class="dv">1</span>,   <span class="dt">sd =</span> <span class="fl">0.5</span>), <span class="dt">nr =</span> nr3))
   )
mat =<span class="st"> </span>mat[<span class="kw">sample</span>(nr, nr), <span class="kw">sample</span>(nc, nc)] <span class="co"># random shuffle rows and columns</span>
<span class="kw">rownames</span>(mat) =<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;row&quot;</span>, <span class="kw">seq_len</span>(nr))
<span class="kw">colnames</span>(mat) =<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;column&quot;</span>, <span class="kw">seq_len</span>(nc))</code></pre></div>
<p>Following command contains the minimal argument for the <code>Heatmap()</code> function which just visualizes the matrix as a heatmap with default settings. Very similar as other heatmap tools, it draws the dendrograms, the row/column names and the heatmap legend. The default color schema is “blue-white-red” which is mapped to the minimal-mean-maximal values in the matrix. The title for the legend is assigned with an internal index number.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/default-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>The title for the legend is taken from the “name” of the heatmap by default. Each heatmap has a name which is like a unique identifier for the heatmap and it is important when you have a list of heatmaps. In later chapters, you will find the heatmap name is used for setting the “main heatmap” and is used for decoration of heatmaps. If the name is not assigned, an internal name is assigned to the heatmap in a form of <code>matrix_%d</code>. In following examples in this chapter, we give the name <code>mat</code> to the heatmap (for which you will see the change of the legend in the next plot).</p>
<p>If you put <code>Heatmap()</code> inside a function or a <code>for</code>/<code>if</code>/<code>while</code> chunk, you won’t see the heatmap after executing <code>Heatmap()</code>. In this case, you need to use <code>draw()</code> function explicitly as follows. We will explain this point in more detail in Section <a href="a-single-heatmap.html#plot-the-heatmap">2.11</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ht =<span class="st"> </span><span class="kw">Heatmap</span>(mat)
<span class="kw">draw</span>(ht)</code></pre></div>
<div id="colors" class="section level2">
<h2><span class="header-section-number">2.1</span> Colors</h2>
<p>For heatmap visualization, colors are the major representation of the data matrix. In most cases, the heatmap visualizes a matrix with continuous numeric values. In this case, users should provide a color mapping function. A color mapping function should accept a vector of values and return a vector of corresponding colors. <strong>Users should always use <code>circlize::colorRamp2()</code> function to generate the color mapping function</strong> with using <code>Heatmap()</code>. The two arguments for <code>colorRamp2()</code> is a vector of break values and a vector of corresponding colors. <code>colorRamp2()</code> linearly interpolates colors in every interval through LAB color space. Also using <code>colorRamp2()</code> helps to generate a legend with proper tick marks.</p>
<p>In following example, values between -2 and 2 are linearly interpolated to get corresponding colors, values larger than 2 are all mapped to red and values less than -2 are all mapped to green.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(circlize)
col_fun =<span class="st"> </span><span class="kw">colorRamp2</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="st">&quot;green&quot;</span>, <span class="st">&quot;white&quot;</span>, <span class="st">&quot;red&quot;</span>))
<span class="kw">col_fun</span>(<span class="kw">seq</span>(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>))</code></pre></div>
<pre><code>## [1] &quot;#00FF00FF&quot; &quot;#00FF00FF&quot; &quot;#B1FF9AFF&quot; &quot;#FFFFFFFF&quot; &quot;#FF9E81FF&quot; &quot;#FF0000FF&quot;
## [7] &quot;#FF0000FF&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-3-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>As you can see, the color mapping function exactly maps negative values to green and positive values to red, even when the distribution of negative values and positive values are not centric to zero. Also this color mapping function is not affected by outliers. In following plot, the clustering is heavily affected by the outlier but not the color mapping.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mat2 =<span class="st"> </span>mat
mat2[<span class="dv">1</span>, <span class="dv">1</span>] =<span class="st"> </span><span class="dv">100000</span>
<span class="kw">Heatmap</span>(mat2, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-4-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>More importantly, <code>colorRamp2()</code> makes colors in multiple heatmaps comparible if they are set with a same color mapping function. In following three heatmaps, a same color always corresponds to a same value.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun, <span class="dt">column_title =</span> <span class="st">&quot;mat&quot;</span>)
<span class="kw">Heatmap</span>(mat<span class="op">/</span><span class="dv">4</span>, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun, <span class="dt">column_title =</span> <span class="st">&quot;mat/4&quot;</span>)
<span class="kw">Heatmap</span>(<span class="kw">abs</span>(mat), <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun, <span class="dt">column_title =</span> <span class="st">&quot;abs(mat)&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-6-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>If the matrix is continuous, you can also simply provide a vector of colors and colors will be linearly interpolated. But remember this method is not robust to outliers because the mapping starts from the minimal value in the matrix and ends with the maximal value. Following color mapping setting is identical to <code>colorRamp2(seq(min(mat), max(mat), length = 10), rev(rainbow(10)))</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> <span class="kw">rev</span>(<span class="kw">rainbow</span>(<span class="dv">10</span>)))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-7-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>If the matrix contains discrete values (either numeric or character), colors should be specified as a named vector to make it possible for the mapping from discrete values to colors. If there is no name for the color, the order of colors corresponds to the order of <code>unique(mat)</code>. Note now the legend is generated from the color mapping vector.</p>
<p>Following sets colors for a discrete numeric matrix (you don’t need to convert it to a character matrix).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">discrete_mat =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dv">100</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>), <span class="dv">10</span>, <span class="dv">10</span>)
colors =<span class="st"> </span><span class="kw">structure</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">names =</span> <span class="kw">c</span>(<span class="st">&quot;1&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;3&quot;</span>, <span class="st">&quot;4&quot;</span>)) <span class="co"># black, red, green, blue</span>
<span class="kw">Heatmap</span>(discrete_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> colors)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-8-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>Or a character matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">discrete_mat =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">sample</span>(letters[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>], <span class="dv">100</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>), <span class="dv">10</span>, <span class="dv">10</span>)
colors =<span class="st"> </span><span class="kw">structure</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">names =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>])
<span class="kw">Heatmap</span>(discrete_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> colors)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/discrete_character_matrix-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>As you see in the two examples above, for the numeric matrix (no matter the color is continuous mapping or discrete mapping), by default clustering is applied on both dimensions while for character matrix, clustering is turned off (but you can still cluster a character matrix if you provide a proper distance metric for two character vectors, see example in Section <a href="a-single-heatmap.html#distance-methods">2.3.1</a>).</p>
<p><code>NA</code> is allowed in the matrix. You can control the color of <code>NA</code> by <code>na_col</code> argument (by default it is grey for <code>NA</code>). <strong>The matrix that contains <code>NA</code> can be clustered by <code>Heatmap()</code>.</strong></p>
<p>Note the <code>NA</code> value is not presented in the legend.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mat_with_na =<span class="st"> </span>mat
na_index =<span class="st"> </span><span class="kw">sample</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>), <span class="kw">nrow</span>(mat)<span class="op">*</span><span class="kw">ncol</span>(mat), <span class="dt">replace =</span> <span class="ot">TRUE</span>, <span class="dt">prob =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">9</span>))
mat_with_na[na_index] =<span class="st"> </span><span class="ot">NA</span>
<span class="kw">Heatmap</span>(mat_with_na, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">na_col =</span> <span class="st">&quot;black&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-9-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>Color space is important for interpolating colors. By default, colors are linearly interpolated in <a href="https://en.wikipedia.org/wiki/Lab_color_space">LAB color space</a>, but you can select the color space in <code>colorRamp2()</code> function. Compare following two plots. Can you see the difference?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f1 =<span class="st"> </span><span class="kw">colorRamp2</span>(<span class="kw">seq</span>(<span class="kw">min</span>(mat), <span class="kw">max</span>(mat), <span class="dt">length =</span> <span class="dv">3</span>), <span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;#EEEEEE&quot;</span>, <span class="st">&quot;red&quot;</span>))
f2 =<span class="st"> </span><span class="kw">colorRamp2</span>(<span class="kw">seq</span>(<span class="kw">min</span>(mat), <span class="kw">max</span>(mat), <span class="dt">length =</span> <span class="dv">3</span>), <span class="kw">c</span>(<span class="st">&quot;blue&quot;</span>, <span class="st">&quot;#EEEEEE&quot;</span>, <span class="st">&quot;red&quot;</span>), 
    <span class="dt">space =</span> <span class="st">&quot;RGB&quot;</span>)
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat1&quot;</span>, <span class="dt">col =</span> f1, <span class="dt">column_title =</span> <span class="st">&quot;LAB color space&quot;</span>)
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat2&quot;</span>, <span class="dt">col =</span> f2, <span class="dt">column_title =</span> <span class="st">&quot;RGB color space&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-11-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>In following plots, corresponding values change evenly on the folded lines, you can see how colors change under different color spaces (top plots: green-black-red, bottom plots: blue-white-red. The plot is made by <a href="https://bioconductor.org/packages/release/bioc/html/HilbertCurve.html"><strong>HilbertCurve</strong>package</a>).</p>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-12-1.png" width="1344" style="display: block; margin: auto;" /><img src="02-single_heatmap_files/figure-html/unnamed-chunk-12-2.png" width="1344" style="display: block; margin: auto;" /></p>
<p>Last but not the least, colors for the heatmap borders can be set by the <code>border</code> and <code>rect_gp</code> arguments. <code>border</code> controls the global border of the heatmap body and <code>rect_gp</code> controls the border of the grids in the heatmap.</p>
<p>The value of <code>border</code> can be logical (<code>TRUE</code> corresponds to <code>black</code>) or a character of color (e.g. <code>red</code>).</p>
<p><code>rect_gp</code> is a <code>gpar</code> object which means you can only set it by <code>grid::gpar()</code>. Since the filled color is already controlled by the heatmap color mapping, you can only set the <code>col</code> parameter in <code>gpar()</code> to control the border of the heatmap grids.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">border =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-13-1.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">rect_gp =</span> <span class="kw">gpar</span>(<span class="dt">col =</span> <span class="st">&quot;white&quot;</span>, <span class="dt">lwd =</span> <span class="dv">2</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-13-2.png" width="480" style="display: block; margin: auto;" /></p>
<p>If <code>col</code> is not set, the default color mapping by <code>Heatmap()</code> is designed with trying to be as convinient and meaningful as possible. Following are the rules for the default color mapping (by <code>ComplexHeatmap:::default_col()</code>):</p>
<ul>
<li>If the values are characters, the colors are generated by <code>circlize::rand_color()</code>;</li>
<li>If the values are from the heatmap annotation and are numeric, colors are mapped between white and one random color by linearly interpolating to the mininum and maxinum.</li>
<li>If the values are from the matrix (let’s denote it as <span class="math inline">\(M\)</span>) which corresponds to the heatmap body:
<ul>
<li>If the fraction of positive values in <span class="math inline">\(M\)</span> is between 25% and 75%, colors are mapped to blue, white and red by linearly interpolating to <span class="math inline">\(-q\)</span>, 0 and <span class="math inline">\(q\)</span>, where <span class="math inline">\(q\)</span> is the maximum of <span class="math inline">\(|M|\)</span> if the number of unique values is less than 100, or <span class="math inline">\(q\)</span> is the 99^th percentile of <span class="math inline">\(|M|\)</span>. This color mapping is centric to zero.</li>
<li>Or else the colors are mapped to blue, white and red by linearly interpolating to <span class="math inline">\(q_1\)</span>, <span class="math inline">\((q_1 + q_2)/2\)</span> and <span class="math inline">\(q_2\)</span>, where <span class="math inline">\(q_1\)</span> and <span class="math inline">\(q_2\)</span> are mininum and maxinum if the number of unique values is <span class="math inline">\(M\)</span> is less than 100, or <span class="math inline">\(q1\)</span> is the 1^th percentile and <span class="math inline">\(q2\)</span> is the 99^th percentile in <span class="math inline">\(M\)</span>.</li>
</ul></li>
</ul>
<p><code>rect_gp</code> allows a non-standard parameter <code>type</code>. If it is set to <code>&quot;none&quot;</code>, the clustering is still applied but nothing in drawn on the heatmap body. The customized graphics on heatmap body can be added via a self-defined <code>cell_fun</code> or <code>layer_fun</code> (see Section <a href="a-single-heatmap.html#customize-the-heatmap-body">2.9</a>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">rect_gp =</span> <span class="kw">gpar</span>(<span class="dt">type =</span> <span class="st">&quot;none&quot;</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-14-1.png" width="480" style="display: block; margin: auto;" /></p>
</div>
<div id="heatmap-titles" class="section level2">
<h2><span class="header-section-number">2.2</span> Titles</h2>
<p>The title of the heatmap basically tells what the plot is about. In <strong>ComplexHeatmap</strong> package, you can set heatmap title either by the row or/and by the column. Note at a same time you can only put e.g. column title either on the top or at the bottom of the heatmap.</p>
<p>The graphic parameters can be set by <code>row_title_gp</code> and <code>column_title_gp</code> respectively. Please remember you should use <code>gpar()</code> to specify graphic parameters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">column_title =</span> <span class="st">&quot;I am a column title&quot;</span>, 
    <span class="dt">row_title =</span> <span class="st">&quot;I am a row title&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/row_column_title-1.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">column_title =</span> <span class="st">&quot;I am a column title at the bottom&quot;</span>, 
    <span class="dt">column_title_side =</span> <span class="st">&quot;bottom&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/row_column_title-2.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">column_title =</span> <span class="st">&quot;I am a big column title&quot;</span>, 
    <span class="dt">column_title_gp =</span> <span class="kw">gpar</span>(<span class="dt">fontsize =</span> <span class="dv">20</span>, <span class="dt">fontface =</span> <span class="st">&quot;bold&quot;</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/row_column_title-3.png" width="480" style="display: block; margin: auto;" /></p>
<p>Rotations for titles can be set by <code>row_title_rot</code> and <code>column_title_rot</code>, but only horizontal and vertical rotations are allowed.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_title =</span> <span class="st">&quot;row title&quot;</span>, <span class="dt">row_title_rot =</span> <span class="dv">0</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/title_rotation-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>Row or column title supports as a template which is used when rows or columns are split in the heatmap (because there will be multiple row/column titles). This functionality is introduced in Section <a href="a-single-heatmap.html#heatmap-split">2.7</a>. A quick example would be:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># code only for demonstration</span>
<span class="co"># row title would be cluster_1 and cluster_2</span>
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">row_title =</span> <span class="st">&quot;cluster_%s&quot;</span>)</code></pre></div>
<p>You can set <code>fill</code> parameter in <code>row_title_gp</code> and <code>column_title_gp</code> to set the background color of titles. Since <code>col</code> in e.g. <code>row_title_gp</code> controls the color of text, <code>border</code> is used to control the color of the background border.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">column_title =</span> <span class="st">&quot;I am a column title&quot;</span>, 
    <span class="dt">column_title_gp =</span> <span class="kw">gpar</span>(<span class="dt">fill =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;white&quot;</span>, <span class="dt">border =</span> <span class="st">&quot;red&quot;</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-16-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>If the graphic elements are texts, they can be set as mathematical formulas.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, 
    <span class="dt">column_title =</span> <span class="kw">expression</span>(<span class="kw">hat</span>(beta) <span class="op">==</span><span class="st"> </span>(X<span class="op">^</span>t <span class="op">*</span><span class="st"> </span>X)<span class="op">^</span>{<span class="op">-</span><span class="dv">1</span>} <span class="op">*</span><span class="st"> </span>X<span class="op">^</span>t <span class="op">*</span><span class="st"> </span>y)) </code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-17-1.png" width="480" style="display: block; margin: auto;" /></p>
</div>
<div id="clustering" class="section level2">
<h2><span class="header-section-number">2.3</span> Clustering</h2>
<p>Clustering might be the key component of the heatmap visualization. In <strong>ComplexHeatmap</strong> package, hierarchical clustering is supported with great flexibility. You can specify the clustering either by:</p>
<ul>
<li>a pre-defined distance method (e.g. <code>&quot;euclidean&quot;</code> or <code>&quot;pearson&quot;</code>),</li>
<li>a distance function,</li>
<li>a object that already contains clustering (a <code>hclust</code> or <code>dendrogram</code> object or object that can be coerced to <code>dendrogram</code> class),</li>
<li>a clustering function.</li>
</ul>
<p>It is also possible to render the dendrograms with different colors and styles for different branches for better revealing structures of the dendrogram (e.g. by <code>dendextend::color_branches()</code>).</p>
<p>First, there are general settings for the clustering, e.g. whether apply clustering or show dendrograms, the side of the dendrograms and heights of the dendrograms.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">cluster_rows =</span> <span class="ot">FALSE</span>) <span class="co"># turn off row clustering</span></code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_basic-1.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">show_column_dend =</span> <span class="ot">FALSE</span>) <span class="co"># hide column dendrogram</span></code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_basic-2.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_dend_side =</span> <span class="st">&quot;right&quot;</span>, <span class="dt">column_dend_side =</span> <span class="st">&quot;bottom&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_basic-3.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">column_dend_height =</span> <span class="kw">unit</span>(<span class="dv">4</span>, <span class="st">&quot;cm&quot;</span>), 
    <span class="dt">row_dend_width =</span> <span class="kw">unit</span>(<span class="dv">4</span>, <span class="st">&quot;cm&quot;</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_basic-4.png" width="480" style="display: block; margin: auto;" /></p>
<div id="distance-methods" class="section level3">
<h3><span class="header-section-number">2.3.1</span> Distance methods</h3>
<p>Hierarchical clustering is performed in two steps: calculate the distance matrix and apply clustering. There are three ways to specify distance metric for clustering:</p>
<ul>
<li>specify distance as a pre-defined option. The valid values are the supported methods in <code>dist()</code> function and in <code>&quot;pearson&quot;</code>, <code>&quot;spearman&quot;</code> and <code>&quot;kendall&quot;</code>. The correlation distance is defined as <code>1 - cor(x, y, method)</code>. All these built-in distance methods allow <code>NA</code> values.</li>
<li>a self-defined function which calculates distance from a matrix. The function should only contain one argument. Please note for clustering on columns, the matrix will be transposed automatically.</li>
<li>a self-defined function which calculates distance from two vectors. The function should only contain two arguments. Note this might be slow because it is implemented by two nested <code>for</code> loop.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">clustering_distance_rows =</span> <span class="st">&quot;pearson&quot;</span>,
    <span class="dt">column_title =</span> <span class="st">&quot;pre-defined distance method (1 - pearson)&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_distance-1.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">clustering_distance_rows =</span> <span class="cf">function</span>(m) <span class="kw">dist</span>(m),
    <span class="dt">column_title =</span> <span class="st">&quot;a function that calculates distance matrix&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_distance-2.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">clustering_distance_rows =</span> <span class="cf">function</span>(x, y) <span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">cor</span>(x, y),
    <span class="dt">column_title =</span> <span class="st">&quot;a function that calculates pairwise distance&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_distance-3.png" width="480" style="display: block; margin: auto;" /></p>
<p>Based on these features, we can apply clustering which is robust to outliers based on the pairwise distance. Note here we set the color mapping function because we don’t want outliers affect the colors.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mat_with_outliers =<span class="st"> </span>mat
<span class="cf">for</span>(i <span class="cf">in</span>  <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>) mat_with_outliers[i, i] =<span class="st"> </span><span class="dv">1000</span>
robust_dist =<span class="st"> </span><span class="cf">function</span>(x, y) {
    qx =<span class="st"> </span><span class="kw">quantile</span>(x, <span class="kw">c</span>(<span class="fl">0.1</span>, <span class="fl">0.9</span>))
    qy =<span class="st"> </span><span class="kw">quantile</span>(y, <span class="kw">c</span>(<span class="fl">0.1</span>, <span class="fl">0.9</span>))
    l =<span class="st"> </span>x <span class="op">&gt;</span><span class="st"> </span>qx[<span class="dv">1</span>] <span class="op">&amp;</span><span class="st"> </span>x <span class="op">&lt;</span><span class="st"> </span>qx[<span class="dv">2</span>] <span class="op">&amp;</span><span class="st"> </span>y <span class="op">&gt;</span><span class="st"> </span>qy[<span class="dv">1</span>] <span class="op">&amp;</span><span class="st"> </span>y <span class="op">&lt;</span><span class="st"> </span>qy[<span class="dv">2</span>]
    x =<span class="st"> </span>x[l]
    y =<span class="st"> </span>y[l]
    <span class="kw">sqrt</span>(<span class="kw">sum</span>((x <span class="op">-</span><span class="st"> </span>y)<span class="op">^</span><span class="dv">2</span>))
}</code></pre></div>
<p>We can compare the two heatmaps with or without the robust distance method:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat_with_outliers, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, 
    <span class="dt">col =</span> <span class="kw">colorRamp2</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="st">&quot;green&quot;</span>, <span class="st">&quot;white&quot;</span>, <span class="st">&quot;red&quot;</span>)),
    <span class="dt">column_title =</span> <span class="st">&quot;dist&quot;</span>)
<span class="kw">Heatmap</span>(mat_with_outliers, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, 
    <span class="dt">col =</span> <span class="kw">colorRamp2</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="st">&quot;green&quot;</span>, <span class="st">&quot;white&quot;</span>, <span class="st">&quot;red&quot;</span>)),
    <span class="dt">clustering_distance_rows =</span> robust_dist,
    <span class="dt">clustering_distance_columns =</span> robust_dist,
    <span class="dt">column_title =</span> <span class="st">&quot;robust_dist&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-19-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>If there are proper distance methods (like methods in <a href="https://cran.r-project.org/web/packages/stringdist/"><strong>stringdist</strong> package</a>), you can also cluster a character matrix. <code>cell_fun</code> argument will be introduced in Section <a href="a-single-heatmap.html#customize-the-heatmap-body">2.9</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mat_letters =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">sample</span>(letters[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>], <span class="dv">100</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>), <span class="dv">10</span>)
<span class="co"># distance in the ASCII table</span>
dist_letters =<span class="st"> </span><span class="cf">function</span>(x, y) {
    x =<span class="st"> </span><span class="kw">strtoi</span>(<span class="kw">charToRaw</span>(<span class="kw">paste</span>(x, <span class="dt">collapse =</span> <span class="st">&quot;&quot;</span>)), <span class="dt">base =</span> <span class="dv">16</span>)
    y =<span class="st"> </span><span class="kw">strtoi</span>(<span class="kw">charToRaw</span>(<span class="kw">paste</span>(y, <span class="dt">collapse =</span> <span class="st">&quot;&quot;</span>)), <span class="dt">base =</span> <span class="dv">16</span>)
    <span class="kw">sqrt</span>(<span class="kw">sum</span>((x <span class="op">-</span><span class="st"> </span>y)<span class="op">^</span><span class="dv">2</span>))
}
<span class="kw">Heatmap</span>(mat_letters, <span class="dt">name =</span> <span class="st">&quot;letters&quot;</span>, <span class="dt">col =</span> <span class="kw">structure</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">names =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>]),
    <span class="dt">clustering_distance_rows =</span> dist_letters, <span class="dt">clustering_distance_columns =</span> dist_letters,
    <span class="dt">cell_fun =</span> <span class="cf">function</span>(j, i, x, y, w, h, col) { <span class="co"># add text to each grid</span>
        <span class="kw">grid.text</span>(mat_letters[i, j], x, y)
    })</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_character_matrix-1.png" width="480" style="display: block; margin: auto;" /></p>
</div>
<div id="clustering-methods" class="section level3">
<h3><span class="header-section-number">2.3.2</span> Clustering methods</h3>
<p>Method to perform hierarchical clustering can be specified by <code>clustering_method_rows</code> and <code>clustering_method_columns</code>. Possible methods are those supported in <code>hclust()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">clustering_method_rows =</span> <span class="st">&quot;single&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_method-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>If you already have a clustering object or a function which directly returns a clustering object, you can ignore the distance settings and set <code>cluster_rows</code> or <code>cluster_columns</code> to the clustering objects or clustering functions. If it is a clustering function, the only argument should be the matrix and it should return a <code>hclust</code> or <code>dendrogram</code> object or a object that can be coerced to the <code>dendrogram</code> class.</p>
<p>In following example, we perform clustering with methods from <strong>cluster</strong> package either by a pre-calculated clustering object or a clustering function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(cluster)
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">cluster_rows =</span> <span class="kw">diana</span>(mat),
   <span class="dt">cluster_columns =</span> <span class="kw">agnes</span>(<span class="kw">t</span>(mat)), <span class="dt">column_title =</span> <span class="st">&quot;clustering objects&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_object-1.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># if cluster_columns is set as a function, you don&#39;t need to transpose the matrix</span>
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">cluster_rows =</span> diana,
   <span class="dt">cluster_columns =</span> agnes, <span class="dt">column_title =</span> <span class="st">&quot;clustering functions&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_object-2.png" width="480" style="display: block; margin: auto;" /></p>
<p>The last command is as same as :</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># code only for demonstration</span>
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">cluster_rows =</span> <span class="cf">function</span>(m) <span class="kw">as.dendrogram</span>(<span class="kw">diana</span>(m)),
    <span class="dt">cluster_columns =</span> <span class="cf">function</span>(m) <span class="kw">as.dendrogram</span>(<span class="kw">agnes</span>(m)), 
    <span class="dt">column_title =</span> <span class="st">&quot;clutering functions&quot;</span>)</code></pre></div>
<p>Please note, when <code>cluster_rows</code> is set as a function, the argument <code>m</code> is the input <code>mat</code> itself, while for <code>cluster_columns</code>, <code>m</code> is the transpose of <code>mat</code>.</p>
<p><code>fastcluster::hclust</code> implements a faster version of <code>hclust()</code>. You can set it to <code>cluster_rows</code> and <code>cluster_columns</code> to use the faster version of <code>hclust()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># code only for demonstration</span>
fh =<span class="st"> </span><span class="cf">function</span>(x) fastcluster<span class="op">::</span><span class="kw">hclust</span>(<span class="kw">dist</span>(x))
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">cluster_rows =</span> fh, <span class="dt">cluster_columns =</span> fh)</code></pre></div>
<p>To make it more convinient to use the faster version of <code>hclust()</code> (assuming you have many heatmaps to construct), it can be set as a global option. The usage of <code>ht_opt</code> is introduced in Section <a href="a-list-of-heatmaps.html#change-parameters-globally">4.13</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># code only for demonstration</span>
ht_opt<span class="op">$</span>fast_hclust =<span class="st"> </span><span class="ot">TRUE</span>
<span class="co"># now fastcluster::hclust is used in all heatmaps</span></code></pre></div>
<p>This is one specific scenario that you might already have a subgroup classification for the matrix rows or columns, and you only want to perform clustering for the features in the same subgroup. There is one way that you can split the heatmap by the subgroup variable (see Section <a href="a-single-heatmap.html#heatmap-split">2.7</a>), or you can use <code>cluster_within_group()</code> clustering function to generate a special dendrogram.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">group =<span class="st"> </span><span class="kw">kmeans</span>(<span class="kw">t</span>(mat), <span class="dt">centers =</span> <span class="dv">3</span>)<span class="op">$</span>cluster
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">cluster_columns =</span> <span class="kw">cluster_within_group</span>(mat, group))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-23-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>In above example, columns in a same group are still clustered, but the dendrogram is degenerated as a flat line. The dendrogram on columns shows the hierarchy of the groups.</p>
</div>
<div id="render-dendrograms" class="section level3">
<h3><span class="header-section-number">2.3.3</span> Render dendrograms</h3>
<p>If you want to render the dendrogram, normally you need to generate a <code>dendrogram</code> object and render it in the first place, then send it to the <code>cluster_rows</code> or <code>cluster_columns</code> argument.</p>
<p>You can render your <code>dendrogram</code> object by the <strong>dendextend</strong> package to make a more customized visualization of the dendrogram. Note <strong>ComplexHeatmap</strong> only allows rendering on the dendrogram lines.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dendextend)
row_dend =<span class="st"> </span><span class="kw">as.dendrogram</span>(<span class="kw">hclust</span>(<span class="kw">dist</span>(mat)))
row_dend =<span class="st"> </span><span class="kw">color_branches</span>(row_dend, <span class="dt">k =</span> <span class="dv">2</span>) <span class="co"># `color_branches()` returns a dendrogram object</span>
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">cluster_rows =</span> row_dend)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_dendextend-1.png" width="480" style="display: block; margin: auto;" /></p>
<p><code>row_dend_gp</code> and <code>column_dend_gp</code> control the global graphic setting for dendrograms. Note e.g. graphic settings in <code>row_dend</code> will be overwritten by <code>row_dend_gp</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">cluster_rows =</span> row_dend, <span class="dt">row_dend_gp =</span> <span class="kw">gpar</span>(<span class="dt">col =</span> <span class="st">&quot;red&quot;</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-24-1.png" width="480" style="display: block; margin: auto;" /></p>
</div>
<div id="reorder-dendrograms" class="section level3">
<h3><span class="header-section-number">2.3.4</span> Reorder dendrograms</h3>
<p>In the <code>Heatmap()</code> function, dendrograms are reordered to make features with larger difference more separated from each others (please refer to the documentation of <code>reorder.dendrogram()</code>). Here the difference (or it is called the weight) is measured by the row means if it is a row dendrogram or by the column means if it is a column dendrogram. <code>row_dend_reorder</code> and <code>column_dend_reorder</code> control whether to apply dendrogram reordering if the value is set as logical. The two arguments also control the weight for the reordering if they are set to numeric vectors (it will be sent to the <code>wts</code> argument of <code>reorder.dendrogram()</code>). The reordering can be turned off by setting e.g. <code>row_dend_reorder = FALSE</code>.</p>
<p>By default, dendrogram reordering is turned on if <code>cluster_rows</code>/<code>cluster_columns</code> is set as logical value or a clustering function. It is turned off if <code>cluster_rows</code>/<code>cluster_columns</code> is set as clustering object.</p>
<p>Compare following two heatmaps:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m2 =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">100</span>, <span class="dt">nr =</span> <span class="dv">10</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)
<span class="kw">Heatmap</span>(m2, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_dend_reorder =</span> <span class="ot">FALSE</span>, <span class="dt">column_title =</span> <span class="st">&quot;no reordering&quot;</span>)
<span class="kw">Heatmap</span>(m2, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_dend_reorder =</span> <span class="ot">TRUE</span>, <span class="dt">column_title =</span> <span class="st">&quot;apply reordering&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cluster_dendsort-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>There are many other methods for reordering dendrograms, e.g. the <strong>dendsort</strong> package. Basically, all these methods still return a dendrogram that has been reordered, thus, we can firstly generate the row or column dendrogram based on the data matrix, reorder it by some method, and assign it back to <code>cluster_rows</code> or <code>cluster_columns</code>.</p>
<p>Compare following two reorderings. Can you tell which is better?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">column_title =</span> <span class="st">&quot;default reordering&quot;</span>)

<span class="kw">library</span>(dendsort)
dend =<span class="st"> </span><span class="kw">dendsort</span>(<span class="kw">hclust</span>(<span class="kw">dist</span>(mat)))
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">cluster_rows =</span> dend, <span class="dt">column_title =</span> <span class="st">&quot;reorder by dendsort&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-27-1.png" width="960" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="row-and_column_orders" class="section level2">
<h2><span class="header-section-number">2.4</span> Set row and column orders</h2>
<p>Clustering is used to adjust row orders and column orders of the heatmap, but you can still set the order manually by <code>row_order</code> and <code>column_order</code>. If e.g. <code>row_order</code> is set, row clustering is turned off by default.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_order =</span> <span class="kw">order</span>(<span class="kw">as.numeric</span>(<span class="kw">gsub</span>(<span class="st">&quot;row&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="kw">rownames</span>(mat)))), 
    <span class="dt">column_order =</span> <span class="kw">order</span>(<span class="kw">as.numeric</span>(<span class="kw">gsub</span>(<span class="st">&quot;column&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="kw">colnames</span>(mat)))))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/manual_order-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>The orders can be character vectors if they are just shuffles of the matrix row names or column names.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_order =</span> <span class="kw">sort</span>(<span class="kw">rownames</span>(mat)), 
    <span class="dt">column_order =</span> <span class="kw">sort</span>(<span class="kw">colnames</span>(mat)))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-28-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>Note <code>row_dend_reorder</code> and <code>row_order</code> are two different things. <code>row_dend_reorder</code> is applied on the dendrogram. For any node in the dendrogram, rotating its two branches actually gives an identical dendrogram, thus, reordering the dendrogram by automatically rotating sub-dendrogram at every node can help to separate elements further from each other which show more difference. As a comparison, <code>row_order</code> is simply applied on the matrix and normally dendrograms should be turned off.</p>
</div>
<div id="heatmap-seriation" class="section level2">
<h2><span class="header-section-number">2.5</span> Seriation</h2>
<p>Seriation is an interesting technique for ordering the matrix (see this interesting post: <a href="http://nicolas.kruchten.com/content/2018/02/seriation/" class="uri">http://nicolas.kruchten.com/content/2018/02/seriation/</a>). The powerful <a href="https://cran.r-project.org/web/packages/seriation/index.html"><strong>seriation</strong> package</a> implements quite a lot of methods for seriation. Since it is easy to extract row orders and column orders from the object returned by the core function <code>seriate()</code> from <strong>seriation</strong> package. They can be directly assigned to <code>row_order</code> and <code>column_order</code> to make the heatmap.</p>
<p>The first example demonstrates to directly apply <code>seriate()</code> on the matrix. Since the <code>&quot;BEA_TSP&quot;</code> method only allows a non-negative matrix, we modify the matrix to <code>max(mat) - mat</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(seriation)
o =<span class="st"> </span><span class="kw">seriate</span>(<span class="kw">max</span>(mat) <span class="op">-</span><span class="st"> </span>mat, <span class="dt">method =</span> <span class="st">&quot;BEA_TSP&quot;</span>)
<span class="kw">Heatmap</span>(<span class="kw">max</span>(mat) <span class="op">-</span><span class="st"> </span>mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, 
    <span class="dt">row_order =</span> <span class="kw">get_order</span>(o, <span class="dv">1</span>), <span class="dt">column_order =</span> <span class="kw">get_order</span>(o, <span class="dv">2</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-29-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>Or you can apply <code>seriate()</code> to the distance matrix. Now the order for rows and columns needs to be calcualted separatedly because the distance matrix needs to be calculated separatedly for columns and rows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">o1 =<span class="st"> </span><span class="kw">seriate</span>(<span class="kw">dist</span>(mat), <span class="dt">method =</span> <span class="st">&quot;TSP&quot;</span>)
o2 =<span class="st"> </span><span class="kw">seriate</span>(<span class="kw">dist</span>(<span class="kw">t</span>(mat)), <span class="dt">method =</span> <span class="st">&quot;TSP&quot;</span>)
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_order =</span> <span class="kw">get_order</span>(o1), <span class="dt">column_order =</span> <span class="kw">get_order</span>(o2))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-30-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>Some seriation methods also contain the hierarchical clustering information. Let’s try:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">o1 =<span class="st"> </span><span class="kw">seriate</span>(<span class="kw">dist</span>(mat), <span class="dt">method =</span> <span class="st">&quot;GW&quot;</span>)
o2 =<span class="st"> </span><span class="kw">seriate</span>(<span class="kw">dist</span>(<span class="kw">t</span>(mat)), <span class="dt">method =</span> <span class="st">&quot;GW&quot;</span>)</code></pre></div>
<p><code>o1</code> and <code>o2</code> are actually mainly composed of <code>hclust</code> objects:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(o1[[<span class="dv">1</span>]])</code></pre></div>
<pre><code>## [1] &quot;ser_permutation_vector&quot; &quot;hclust&quot;</code></pre>
<p>And the orders are the same by using <code>hclust$order</code> or <code>get_order()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">o1[[<span class="dv">1</span>]]<span class="op">$</span>order</code></pre></div>
<pre><code>##  [1]  1  2 11 12  5 15 16 17  7  8  6  9 10 18 13  4  3 14</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># should be the same as the previous one</span>
<span class="kw">get_order</span>(o1)</code></pre></div>
<pre><code>##  [1]  1  2 11 12  5 15 16 17  7  8  6  9 10 18 13  4  3 14</code></pre>
<p>And we can add the dendrograms to the heatmap.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">cluster_rows =</span> <span class="kw">as.dendrogram</span>(o1[[<span class="dv">1</span>]]), 
    <span class="dt">cluster_columns =</span> <span class="kw">as.dendrogram</span>(o2[[<span class="dv">1</span>]]))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-34-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>For more use of the <code>seriate()</code> function, please refer to the <a href="https://cran.r-project.org/web/packages/seriation/index.html"><strong>seriation</strong> package</a>.</p>
</div>
<div id="dimension-names" class="section level2">
<h2><span class="header-section-number">2.6</span> Dimension names</h2>
<p>The row names and column names are drawn on the right and bottom sides of the heatmap by default. Side, visibility and graphic parameters for dimension names can be set as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_names_side =</span> <span class="st">&quot;left&quot;</span>, <span class="dt">row_dend_side =</span> <span class="st">&quot;right&quot;</span>, 
    <span class="dt">column_names_side =</span> <span class="st">&quot;top&quot;</span>, <span class="dt">column_dend_side =</span> <span class="st">&quot;bottom&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/dimension_name-1.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">show_row_names =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/dimension_name-2.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_names_gp =</span> <span class="kw">gpar</span>(<span class="dt">fontsize =</span> <span class="dv">20</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/dimension_name-3.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_names_gp =</span> <span class="kw">gpar</span>(<span class="dt">col =</span> <span class="kw">c</span>(<span class="kw">rep</span>(<span class="st">&quot;red&quot;</span>, <span class="dv">10</span>), <span class="kw">rep</span>(<span class="st">&quot;blue&quot;</span>, <span class="dv">8</span>))))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/dimension_name-4.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_names_centered =</span> <span class="ot">TRUE</span>, <span class="dt">column_names_centered =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/dimension_name-5.png" width="480" style="display: block; margin: auto;" /></p>
<p>The rotation of column names can be set by <code>column_names_rot</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">column_names_rot =</span> <span class="dv">45</span>)
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">column_names_rot =</span> <span class="dv">45</span>, <span class="dt">column_names_side =</span> <span class="st">&quot;top&quot;</span>,
    <span class="dt">column_dend_side =</span> <span class="st">&quot;bottom&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-36-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>If you have row names or column names which are too long, <code>row_names_max_width</code> or <code>column_names_max_height</code> can be used to set the maximal space for them. The default maximal space for row names and column names are all 6 cm. In following code, <code>max_text_width()</code> is a helper function to quick calculate maximal width from a vector of text.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mat2 =<span class="st"> </span>mat
<span class="kw">rownames</span>(mat2)[<span class="dv">1</span>] =<span class="st"> </span><span class="kw">paste</span>(<span class="kw">c</span>(letters, LETTERS), <span class="dt">collapse =</span> <span class="st">&quot;&quot;</span>)
<span class="kw">Heatmap</span>(mat2, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>)
<span class="kw">Heatmap</span>(mat2, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, 
    <span class="dt">row_names_max_width =</span> <span class="kw">max_text_width</span>(
        <span class="kw">rownames</span>(mat2), 
        <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fontsize =</span> <span class="dv">12</span>)
    ))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-38-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Instead of directly using the row/column names from the matrix, you can also provide another character vector which corresponds to the rows or columns and set it by <code>row_labels</code> or <code>column_labels</code>. This is useful because you don’t need to change the dimension names of the matrix to change the labels on the heatmap while you can directly provide the new labels.</p>
<p>There is one typical scenario that <code>row_labels</code> and <code>column_labels</code> are useful. For the gene expression analysis, we might use Ensembl ID as the gene ID which is used as row names of the gene expression matrix. However, the Ensembl ID is for the indexing of the Ensembl database but not for the human reading. Instead, we would prefer to put gene symbols on the heatmap as the row names which is easier to read. To do this, we only need to assign the corresponding gene symbols to <code>row_labels</code> without modifying the original matrix.</p>
<p>The second advantage is <code>row_labels</code> or <code>column_labels</code> allows duplicated labels, while duplicated row names or column names are not allowed in the matrix.</p>
<p>Following gives a simple example that we put letters as row labels and column labels:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># use a named vector to make sure the correspondance between </span>
<span class="co"># row names and row labels is correct</span>
row_labels =<span class="st"> </span><span class="kw">structure</span>(<span class="kw">paste0</span>(letters[<span class="dv">1</span><span class="op">:</span><span class="dv">24</span>], <span class="dv">1</span><span class="op">:</span><span class="dv">24</span>), <span class="dt">names =</span> <span class="kw">paste0</span>(<span class="st">&quot;row&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">24</span>))
column_labels =<span class="st"> </span><span class="kw">structure</span>(<span class="kw">paste0</span>(LETTERS[<span class="dv">1</span><span class="op">:</span><span class="dv">24</span>], <span class="dv">1</span><span class="op">:</span><span class="dv">24</span>), <span class="dt">names =</span> <span class="kw">paste0</span>(<span class="st">&quot;column&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">24</span>))
row_labels</code></pre></div>
<pre><code>##  row1  row2  row3  row4  row5  row6  row7  row8  row9 row10 row11 row12 
##  &quot;a1&quot;  &quot;b2&quot;  &quot;c3&quot;  &quot;d4&quot;  &quot;e5&quot;  &quot;f6&quot;  &quot;g7&quot;  &quot;h8&quot;  &quot;i9&quot; &quot;j10&quot; &quot;k11&quot; &quot;l12&quot; 
## row13 row14 row15 row16 row17 row18 row19 row20 row21 row22 row23 row24 
## &quot;m13&quot; &quot;n14&quot; &quot;o15&quot; &quot;p16&quot; &quot;q17&quot; &quot;r18&quot; &quot;s19&quot; &quot;t20&quot; &quot;u21&quot; &quot;v22&quot; &quot;w23&quot; &quot;x24&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_labels =</span> row_labels[<span class="kw">rownames</span>(mat)], 
    <span class="dt">column_labels =</span> column_labels[<span class="kw">colnames</span>(mat)])</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-39-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>The third advantage is mathematical expression can be used as row names in the heatmap.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_labels =</span> <span class="kw">expression</span>(alpha, beta, gamma, delta, epsilon, 
    zeta, eta, theta, iota, kappa, lambda, mu, nu, xi, omicron, pi, rho, sigma))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-40-1.png" width="480" style="display: block; margin: auto;" /></p>
<p><code>anno_text()</code> (Section <a href="heatmap-annotations.html#text-annotation">3.14</a>) can be used to add more customized labels for heatmap rows and columns.</p>
</div>
<div id="heatmap-split" class="section level2">
<h2><span class="header-section-number">2.7</span> Heatmap split</h2>
<p>One major advantage of <strong>ComplexHeatmap</strong> package is it supports splitting the heatmap by rows and columns to better group the features and additionally highlight the patterns.</p>
<p>Following arguments control the splitting: <code>row_km</code>, <code>row_split</code>, <code>column_km</code>, <code>column_split</code>. In following, we call the sub-clusters generated by splitting “<em>slices</em>”.</p>
<div id="split-by-kmeans-clustering" class="section level3">
<h3><span class="header-section-number">2.7.1</span> Split by k-means clustering</h3>
<p><code>row_km</code> and <code>column_km</code> apply k-means partitioning.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_km =</span> <span class="dv">2</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/k_means-1.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">column_km =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/k_means-2.png" width="480" style="display: block; margin: auto;" /></p>
<p>Row splitting and column splitting can be performed simultaneously.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-41-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>You might notice there are dashed lines in the row and column dendrograms, it will be explained in Section <a href="a-single-heatmap.html#split-by-categorical-variables">2.7.2</a> (last paragraph).</p>
<p><code>Heatmap()</code> internally calls <code>kmeans()</code> with random start points, which results in, for some cases, generating different clusters from repeated runs. To get rid of this problem, <code>row_km_repeats</code> and <code>column_km_repeats</code> can be set to a number larger than 1 to run <code>kmeans()</code> multiple times and a final consensus k-means clustering is used. Please note the final number of clusters form consensus k-means might be smaller than the number set in <code>row_km</code> and <code>column_km</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, 
    <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">row_km_repeats =</span> <span class="dv">100</span>,
    <span class="dt">column_km =</span> <span class="dv">3</span>, <span class="dt">column_km_repeats =</span> <span class="dv">100</span>)</code></pre></div>
</div>
<div id="split-by-categorical-variables" class="section level3">
<h3><span class="header-section-number">2.7.2</span> Split by categorical variables</h3>
<p>More generally, <code>row_split</code> or <code>column_split</code> can be set to a categorical vector or a data frame where different combinations of levels split the rows/columns in the heatmap. How to control the order of the slices is introduced in Section <a href="a-single-heatmap.html#order-of-slices">2.7.4</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># split by a vector</span>
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, 
    <span class="dt">row_split =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="dv">9</span>), <span class="dt">column_split =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;C&quot;</span>, <span class="st">&quot;D&quot;</span>), <span class="dv">12</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/split-1.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># split by a data frame</span>
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, 
    <span class="dt">row_split =</span> <span class="kw">data.frame</span>(<span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="dv">9</span>), <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;C&quot;</span>, <span class="st">&quot;D&quot;</span>), <span class="dt">each =</span> <span class="dv">9</span>)))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/split-2.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># split on both dimensions</span>
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> <span class="kw">factor</span>(<span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="dv">9</span>)),
    <span class="dt">column_split =</span> <span class="kw">factor</span>(<span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;C&quot;</span>, <span class="st">&quot;D&quot;</span>), <span class="dv">12</span>)))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/split-3.png" width="480" style="display: block; margin: auto;" /></p>
<p>Actually, k-means clustering just generates a vector of cluster classes and appends to <code>row_split</code> or <code>column_split</code>. <code>row_km</code>/<code>column_km</code> and be used mixed with <code>row_split</code> and <code>column_split</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="dv">9</span>), <span class="dt">row_km =</span> <span class="dv">2</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-43-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>which is the same as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># code only for demonstration</span>
cl =<span class="st"> </span><span class="kw">kmeans</span>(mat, <span class="dt">centers =</span> <span class="dv">2</span>)<span class="op">$</span>cluster
<span class="co"># classes from k-means are always put as the first column in `row_split`</span>
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> <span class="kw">cbind</span>(cl, <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="dv">9</span>)))</code></pre></div>
<p>If you are not happy with the default k-means partition, it is easy to use other partition methods by just assigning the partition vector to <code>row_split</code>/<code>column_split</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pa =<span class="st"> </span>cluster<span class="op">::</span><span class="kw">pam</span>(mat, <span class="dt">k =</span> <span class="dv">3</span>)
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> <span class="kw">paste0</span>(<span class="st">&quot;pam&quot;</span>, pa<span class="op">$</span>clustering))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/pam-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>If <code>row_order</code> or <code>column_order</code> is set, in each row/column slice, it is still ordered.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># remember when `row_order` is set, row clustering is turned off</span>
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_order =</span> <span class="dv">18</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">row_km =</span> <span class="dv">2</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/split_row_order-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>Character matrix can only be split by <code>row_split</code>/<code>column_split</code> argument.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># split by the first column in `discrete_mat`</span>
<span class="kw">Heatmap</span>(discrete_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">row_split =</span> discrete_mat[, <span class="dv">1</span>])</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/split_discrete_matrix-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>If <code>row_km</code>/<code>column_km</code> is set or <code>row_split</code>/<code>column_split</code> is set as a vector or a data frame, hierarchical clustering is first applied to each slice (of course, clustering should be turned on) which generates <code>k</code> dendrograms, then a parent dendrogram is generated based on the mean values of each slice. <strong>The height of the parent dendrogram is adjusted by adding the maximal height of the dendrograms in all children slices and the parent dendrogram is added on top of the children dendrograms to form a single global dendrogram.</strong> This is why you see dashed lines in the dendrograms in previous heatmaps. They are used to mark the parent dendrogram and the children dendrograms, and alert users they are calculated in different ways. These dashed lines can be removed by setting <code>show_parent_dend_line = FALSE</code> in <code>Heatmap()</code>, or set it as a global option: <code>ht_opt$show_parent_dend_line = FALSE</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">3</span>, <span class="dt">show_parent_dend_line =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-45-1.png" width="480" style="display: block; margin: auto;" /></p>
</div>
<div id="spilt-by-dendrogram" class="section level3">
<h3><span class="header-section-number">2.7.3</span> Split by dendrogram</h3>
<p>A second scenario for splitting is that users may still want to keep the global dendrogram <strong>which is generated from the complete matrix</strong> while not split it in the first place. In this case, <code>row_split</code>/<code>column_split</code> can be set to a single number which will apply <code>cutree()</code> on the row/column dendrogram. This works when <code>cluster_rows</code>/<code>cluster_columns</code> is set to <code>TRUE</code> or is assigned with a <code>hclust</code>/<code>dendrogram</code> object.</p>
<p>For this case, the dendrogram is still as same as the original one, expect the positions of dendrogram leaves are slightly adjusted by the gaps between slices. (There is no dashed lines, because here the dendrogram is calcualted as a complete one and there is no parent dendrogram or children dendrograms.)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> <span class="dv">2</span>, <span class="dt">column_split =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/split_dendrogram-1.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dend =<span class="st"> </span><span class="kw">hclust</span>(<span class="kw">dist</span>(mat))
dend =<span class="st"> </span><span class="kw">color_branches</span>(dend, <span class="dt">k =</span> <span class="dv">2</span>)
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">cluster_rows =</span> dend, <span class="dt">row_split =</span> <span class="dv">2</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/split_dendrogram-2.png" width="480" style="display: block; margin: auto;" /></p>
<p>If you want to combine splitting from <code>cutree()</code> and other categorical variables, you need to generate the classes from <code>cutree()</code> in the first place, append to e.g. <code>row_split</code> as a data frame and then send it to <code>row_split</code> argument.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># code only for demonstration</span>
split =<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">cutree</span>(<span class="kw">hclust</span>(<span class="kw">dist</span>(mat)), <span class="dt">k =</span> <span class="dv">2</span>), <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="dv">9</span>))
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> split)</code></pre></div>
</div>
<div id="order-of-slices" class="section level3">
<h3><span class="header-section-number">2.7.4</span> Order of slices</h3>
<p>When <code>row_split</code>/<code>column_split</code> is set as categorical variable (a vector or a data frame) or <code>row_km</code>/<code>column_km</code> is set, by default, there is an additional clustering applied to the mean of slices to show the hierarchy in the slice level. Under this scenario, you cannot precisely control the order of slices because it is controlled by the clustering of slices.</p>
<p>Nevertheless, you can set <code>cluster_row_slices</code> or <code>cluster_column_slices</code> to <code>FALSE</code> to turn off the clustering on slices, and now you can precisely control the order of slices.</p>
<p>When there is no slice clustering, the order of each slice can be controlled by <code>levels</code> of each variable in <code>row_split</code>/<code>column_split</code> (in this case, each variable should be a factor). If all variables are characters, the default order is <code>unique(row_split)</code> or <code>unique(column_split)</code>. Compare following heatmaps:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, 
  <span class="dt">row_split =</span> <span class="kw">rep</span>(LETTERS[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], <span class="dv">6</span>),
    <span class="dt">column_split =</span> <span class="kw">rep</span>(letters[<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>], <span class="dv">4</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-47-1.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># clustering is similar as previous heatmap with branches in some nodes in the dendrogram flipped</span>
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, 
  <span class="dt">row_split =</span> <span class="kw">factor</span>(<span class="kw">rep</span>(LETTERS[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], <span class="dv">6</span>), <span class="dt">levels =</span> LETTERS[<span class="dv">3</span><span class="op">:</span><span class="dv">1</span>]),
    <span class="dt">column_split =</span> <span class="kw">factor</span>(<span class="kw">rep</span>(letters[<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>], <span class="dv">4</span>), <span class="dt">levels =</span> letters[<span class="dv">6</span><span class="op">:</span><span class="dv">1</span>]))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-47-2.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># now the order is exactly what we set</span>
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, 
  <span class="dt">row_split =</span> <span class="kw">factor</span>(<span class="kw">rep</span>(LETTERS[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], <span class="dv">6</span>), <span class="dt">levels =</span> LETTERS[<span class="dv">3</span><span class="op">:</span><span class="dv">1</span>]),
    <span class="dt">column_split =</span> <span class="kw">factor</span>(<span class="kw">rep</span>(letters[<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>], <span class="dv">4</span>), <span class="dt">levels =</span> letters[<span class="dv">6</span><span class="op">:</span><span class="dv">1</span>]),
    <span class="dt">cluster_row_slices =</span> <span class="ot">FALSE</span>, 
    <span class="dt">cluster_column_slices =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-47-3.png" width="480" style="display: block; margin: auto;" /></p>
</div>
<div id="titles-for-splitting" class="section level3">
<h3><span class="header-section-number">2.7.5</span> Titles for splitting</h3>
<p>When <code>row_split</code>/<code>column_split</code> is set as a single number, there is only one categorical variable, while when <code>row_km</code>/<code>column_km</code> is set and/or <code>row_split</code>/<code>column_split</code> is set as categorical variables, there will be multiple categorical variables. By default, the titles are in a form of <code>&quot;level1,level2,...&quot;</code> which corresponds to every combination of levels in all categorical variables. The titles for splitting can be controlled by “a title template”.</p>
<p><strong>ComplexHeatmap</strong> supports three types of templates. The first one is by <code>sprintf()</code> where the <code>%s</code> is replaced by the corresponding level. In following example, since all combinations of <code>split</code> are <code>A,C</code>, <code>A,D</code>, <code>B,C</code> and <code>B,D</code>, if <code>row_title</code> is set to <code>%s|%s</code>, the four row titles will be <code>A|C</code>, <code>A|D</code>, <code>B|C</code>, <code>B|D</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">split =<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>), <span class="dv">9</span>), <span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;C&quot;</span>, <span class="st">&quot;D&quot;</span>), <span class="dt">each =</span> <span class="dv">9</span>))
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> split, <span class="dt">row_title =</span> <span class="st">&quot;%s|%s&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-48-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>For the <code>sprintf()</code> template, you can only put the levels which are <code>A,B,C,D</code> in the title, and <code>C,D</code> is always after <code>A,B</code>. However, when making the heatmap, you might want to put more meaningful text instead of the internal levels. Once you know how to correspond the text to the level, you can add it by following two template methods.</p>
<p>In the following two template methods, special marks are used to mark the R code which is executable (it is called variable interpolation where the code is extracted and executed and the returned value in put back to the string). There are two types of template marks <code>@{}</code> and <code>{}</code>. The first one is from <strong>GetoptLong</strong> package which should already be installed when you install the <strong>ComplexHeatmap</strong> package and the second one is from <strong>glue</strong> package which you need to install first.</p>
<p>There is an internal variable <code>x</code> you should use when you use the latter two templates. <code>x</code> is just a simple vector which contains current category levels (e.g. <code>c(&quot;A&quot;, &quot;C&quot;)</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># We only run the code for the first heatmap</span>
map =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;A&quot;</span> =<span class="st"> &quot;aaa&quot;</span>, <span class="st">&quot;B&quot;</span> =<span class="st"> &quot;bbb&quot;</span>, <span class="st">&quot;C&quot;</span> =<span class="st"> &quot;333&quot;</span>, <span class="st">&quot;D&quot;</span> =<span class="st"> &quot;444&quot;</span>)
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> split, <span class="dt">row_title =</span> <span class="st">&quot;@{map[ x[1] ]}|@{map[ x[2] ]}&quot;</span>)
<span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> split, <span class="dt">row_title =</span> <span class="st">&quot;{map[ x[1] ]}|{map[ x[2] ]}&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-50-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>The row title is rotated by default, you can set <code>row_title_rot = 0</code> to make it horizontal:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> split, <span class="dt">row_title =</span> <span class="st">&quot;%s|%s&quot;</span>, <span class="dt">row_title_rot =</span> <span class="dv">0</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-51-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>When <code>row_split</code>/<code>column_split</code> is set as a number, you can also use template to adjust the titles for slices.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> <span class="dv">2</span>, <span class="dt">row_title =</span> <span class="st">&quot;cluster_%s&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-52-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>If you know the final number of row slices, you can directly set a vector of titles to <code>row_title</code>. Be careful the number of row slices is not always identical to <code>nlevel_1*nlevel_2*...</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> split, 
    <span class="dt">row_title =</span> <span class="kw">c</span>(<span class="st">&quot;top_slice&quot;</span>, <span class="st">&quot;middle_top_slice&quot;</span>, <span class="st">&quot;middle_bottom_slice&quot;</span>, <span class="st">&quot;bottom_slice&quot;</span>),
    <span class="dt">row_title_rot =</span> <span class="dv">0</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-53-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>If the length of <code>row_title</code> is specified as a single string, it will be like a single title for all slices.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> split, <span class="dt">row_title =</span> <span class="st">&quot;there are four slices&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-54-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>If you still want titles for each slice, but also a global title, you can do as follows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ht =<span class="st"> </span><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> split, <span class="dt">row_title =</span> <span class="st">&quot;%s|%s&quot;</span>)
<span class="kw">draw</span>(ht, <span class="dt">row_title =</span> <span class="st">&quot;I am a row title&quot;</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-55-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>Actually the <code>row_title</code> used in <code>draw()</code> function is the row title of the heatmap list, although in the example there is only one heatmap. The <code>draw()</code> function and the heatmap list will be introduced in Chapter <a href="a-list-of-heatmaps.html#a-list-of-heatmaps">4</a>.</p>
<p>If <code>row_title</code> is set to <code>NULL</code>, no row title will be drawn.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_split =</span> split, <span class="dt">row_title =</span> <span class="ot">NULL</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-56-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>All these rules also work for column titles for slices.</p>
</div>
<div id="graphic-parameters-for-splitting" class="section level3">
<h3><span class="header-section-number">2.7.6</span> Graphic parameters for splitting</h3>
<p>When splitting is applied on rows/columns, graphic parameters for row/column title and row/column names can be specified as same length as number of slices.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, 
    <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">row_title_gp =</span> <span class="kw">gpar</span>(<span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;red&quot;</span>, <span class="st">&quot;blue&quot;</span>), <span class="dt">font =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>),
    <span class="dt">row_names_gp =</span> <span class="kw">gpar</span>(<span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;green&quot;</span>, <span class="st">&quot;orange&quot;</span>), <span class="dt">fontsize =</span> <span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">14</span>)),
    <span class="dt">column_km =</span> <span class="dv">3</span>, <span class="dt">column_title_gp =</span> <span class="kw">gpar</span>(<span class="dt">fill =</span> <span class="kw">c</span>(<span class="st">&quot;red&quot;</span>, <span class="st">&quot;blue&quot;</span>, <span class="st">&quot;green&quot;</span>), <span class="dt">font =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>),
    <span class="dt">column_names_gp =</span> <span class="kw">gpar</span>(<span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;green&quot;</span>, <span class="st">&quot;orange&quot;</span>, <span class="st">&quot;purple&quot;</span>), <span class="dt">fontsize =</span> <span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">14</span>, <span class="dv">8</span>)))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/split_graphical_parameter-1.png" width="480" style="display: block; margin: auto;" /></p>
</div>
<div id="gaps-between-slices" class="section level3">
<h3><span class="header-section-number">2.7.7</span> Gaps between slices</h3>
<p>The space of gaps between row/column slices can be controlled by <code>row_gap</code>/<code>column_gap</code>. The value can be a single unit or a vector of units.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_km =</span> <span class="dv">3</span>, <span class="dt">row_gap =</span> <span class="kw">unit</span>(<span class="dv">5</span>, <span class="st">&quot;mm&quot;</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/split_gap-1.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_km =</span> <span class="dv">3</span>, <span class="dt">row_gap =</span> <span class="kw">unit</span>(<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>), <span class="st">&quot;mm&quot;</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/split_gap-2.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_km =</span> <span class="dv">3</span>, <span class="dt">row_gap =</span> <span class="kw">unit</span>(<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>), <span class="st">&quot;mm&quot;</span>),
    <span class="dt">column_km =</span> <span class="dv">3</span>, <span class="dt">column_gap =</span> <span class="kw">unit</span>(<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>), <span class="st">&quot;mm&quot;</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/split_gap-3.png" width="480" style="display: block; margin: auto;" /></p>
<p>When heatmap border is added by setting <code>border = TRUE</code>, the border of every slice is added.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">3</span>, <span class="dt">border =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-57-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>If you set gap size to zero, the heatmap will look like it is partitioned by vertical and horizontal lines.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">3</span>, 
    <span class="dt">row_gap =</span> <span class="kw">unit</span>(<span class="dv">0</span>, <span class="st">&quot;mm&quot;</span>), <span class="dt">column_gap =</span> <span class="kw">unit</span>(<span class="dv">0</span>, <span class="st">&quot;mm&quot;</span>), <span class="dt">border =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-58-1.png" width="480" style="display: block; margin: auto;" /></p>
</div>
<div id="split-heatmap-annotations" class="section level3">
<h3><span class="header-section-number">2.7.8</span> Split heatmap annotations</h3>
<p>When the heatmap is split, all the heatmap components are split accordingly. Following gives you a simple example and the heatmap annotation will be introduced in Chapter <a href="heatmap-annotations.html#heatmap-annotations">3</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">3</span>,
    <span class="dt">top_annotation =</span> <span class="kw">HeatmapAnnotation</span>(<span class="dt">foo1 =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">24</span>, <span class="dt">bar1 =</span> <span class="kw">anno_points</span>(<span class="kw">runif</span>(<span class="dv">24</span>))),
    <span class="dt">right_annotation =</span> <span class="kw">rowAnnotation</span>(<span class="dt">foo2 =</span> <span class="dv">18</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">bar2 =</span> <span class="kw">anno_barplot</span>(<span class="kw">runif</span>(<span class="dv">18</span>)))
)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-59-1.png" width="576" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="heatmap-as-raster-image" class="section level2">
<h2><span class="header-section-number">2.8</span> Heatmap as raster image</h2>
<p>Saving plots in PDF format is kind like best parctice to preserve the quality of the plots. However, when there are too many rows (say, &gt; 10000), the output PDF file would be huge and it takes long time and memory to read the whole plot. On the other hand, details of the huge matrix will not be seen in limited size of PDF file. Rendering heatmaps (the heatmap body) as raster images will effectively reduce the file size while the plot looks exactly the same for your screen or if you print it out. In <code>Heatmap()</code> function, there are four options which control how to generate the raster image: <code>use_raster</code>, <code>raster_device</code>, <code>raster_quality</code>, <code>raster_device_param</code>.</p>
<p>You can choose graphic device (<code>png</code>, <code>jpeg</code> and <code>tiff</code>) by <code>raster_device</code>, control the quality of the raster image by <code>raster_quality</code>, and pass further parameters for a specific device by <code>raster_device_param</code>.</p>
<p>If <code>raster_quality</code> is set to 1, internally, a PNG (if <code>raster_device</code> is set to <code>png</code>) file is generated with the same physical size as the heatmap body and refit into the heatmap body as a raster image. The png file generated has the size of <code>raster_quality*width</code> and <code>raster_quality*height</code>. So a larger <code>raster_quality</code> value gives you a better reservation of the original resolution.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># code only for demonstration</span>
<span class="kw">Heatmap</span>(mat, <span class="dt">use_raster =</span> <span class="ot">TRUE</span>, <span class="dt">raster_quality =</span> <span class="dv">2</span>)</code></pre></div>
<p>In <strong>Complexheatmap</strong>, <code>use_raster</code> is by default turned on if the number of rows or columns is more than 2000.</p>
<p>Following example compares the PDF file size with raster image by different devices.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123</span>)
mat2 =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">10000</span><span class="op">*</span><span class="dv">100</span>), <span class="dt">ncol =</span> <span class="dv">100</span>)
<span class="kw">pdf</span>(<span class="st">&quot;heatmap.pdf&quot;</span>, <span class="dt">width =</span> <span class="dv">8</span>, <span class="dt">height =</span> <span class="dv">8</span>)
<span class="kw">Heatmap</span>(mat2, <span class="dt">cluster_rows =</span> <span class="ot">FALSE</span>, <span class="dt">cluster_columns =</span> <span class="ot">FALSE</span>, <span class="dt">use_raster =</span> <span class="ot">FALSE</span>)
<span class="kw">dev.off</span>()

<span class="kw">pdf</span>(<span class="st">&quot;heatmap_raster_by_png.pdf&quot;</span>, <span class="dt">width =</span> <span class="dv">8</span>, <span class="dt">height =</span> <span class="dv">8</span>)
<span class="kw">Heatmap</span>(mat2, <span class="dt">cluster_rows =</span> <span class="ot">FALSE</span>, <span class="dt">cluster_columns =</span> <span class="ot">FALSE</span>, <span class="dt">use_raster =</span> <span class="ot">TRUE</span>, 
    <span class="dt">raster_device =</span> <span class="st">&quot;png&quot;</span>)
<span class="kw">dev.off</span>()

<span class="kw">pdf</span>(<span class="st">&quot;heatmap_raster_by_jpeg.pdf&quot;</span>, <span class="dt">width =</span> <span class="dv">8</span>, <span class="dt">height =</span> <span class="dv">8</span>)
<span class="kw">Heatmap</span>(mat2, <span class="dt">cluster_rows =</span> <span class="ot">FALSE</span>, <span class="dt">cluster_columns =</span> <span class="ot">FALSE</span>, <span class="dt">use_raster =</span> <span class="ot">TRUE</span>, 
    <span class="dt">raster_device =</span> <span class="st">&quot;jpeg&quot;</span>)
<span class="kw">dev.off</span>()

<span class="kw">pdf</span>(<span class="st">&quot;heatmap_raster_by_tiff.pdf&quot;</span>, <span class="dt">width =</span> <span class="dv">8</span>, <span class="dt">height =</span> <span class="dv">8</span>)
<span class="kw">Heatmap</span>(mat2, <span class="dt">cluster_rows =</span> <span class="ot">FALSE</span>, <span class="dt">cluster_columns =</span> <span class="ot">FALSE</span>, <span class="dt">use_raster =</span> <span class="ot">TRUE</span>, 
    <span class="dt">raster_device =</span> <span class="st">&quot;tiff&quot;</span>)
<span class="kw">dev.off</span>()

<span class="kw">pdf</span>(<span class="st">&quot;heatmap_raster_by_CairoPNG.pdf&quot;</span>, <span class="dt">width =</span> <span class="dv">8</span>, <span class="dt">height =</span> <span class="dv">8</span>)
<span class="kw">Heatmap</span>(mat2, <span class="dt">cluster_rows =</span> <span class="ot">FALSE</span>, <span class="dt">cluster_columns =</span> <span class="ot">FALSE</span>, <span class="dt">use_raster =</span> <span class="ot">TRUE</span>, 
    <span class="dt">raster_device =</span> <span class="st">&quot;CairoPNG&quot;</span>)
<span class="kw">dev.off</span>()

<span class="kw">pdf</span>(<span class="st">&quot;heatmap_raster_by_CairoJPEG.pdf&quot;</span>, <span class="dt">width =</span> <span class="dv">8</span>, <span class="dt">height =</span> <span class="dv">8</span>)
<span class="kw">Heatmap</span>(mat2, <span class="dt">cluster_rows =</span> <span class="ot">FALSE</span>, <span class="dt">cluster_columns =</span> <span class="ot">FALSE</span>, <span class="dt">use_raster =</span> <span class="ot">TRUE</span>, 
    <span class="dt">raster_device =</span> <span class="st">&quot;CairoJPEG&quot;</span>)
<span class="kw">dev.off</span>()</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">all_files =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;heatmap.pdf&quot;</span>, <span class="st">&quot;heatmap_raster_by_png.pdf&quot;</span>, 
              <span class="st">&quot;heatmap_raster_by_jpeg.pdf&quot;</span>, <span class="st">&quot;heatmap_raster_by_tiff.pdf&quot;</span>,
              <span class="st">&quot;heatmap_raster_by_CairoPNG.pdf&quot;</span>, <span class="st">&quot;heatmap_raster_by_CairoJPEG.pdf&quot;</span>)
fs =<span class="st"> </span><span class="kw">file.size</span>(all_files)
<span class="kw">names</span>(fs) =<span class="st"> </span>all_files
<span class="kw">sapply</span>(fs, <span class="cf">function</span>(x) <span class="kw">paste</span>(<span class="kw">round</span>(x<span class="op">/</span><span class="dv">1024</span>), <span class="st">&quot;KB&quot;</span>))</code></pre></div>
<pre><code>##                     heatmap.pdf       heatmap_raster_by_png.pdf 
##                       &quot;6583 KB&quot;                        &quot;374 KB&quot; 
##      heatmap_raster_by_jpeg.pdf      heatmap_raster_by_tiff.pdf 
##                       &quot;2845 KB&quot;                        &quot;374 KB&quot; 
##  heatmap_raster_by_CairoPNG.pdf heatmap_raster_by_CairoJPEG.pdf 
##                        &quot;307 KB&quot;                       &quot;2975 KB&quot;</code></pre>
</div>
<div id="customize-the-heatmap-body" class="section level2">
<h2><span class="header-section-number">2.9</span> Customize the heatmap body</h2>
<p>The heatmap body can be self-defined to add more types of graphics. By default the heatmap body is composed by a matrix of small rectangles (it might be called grids in other parts of this documentation, but let’s call it “<em>cells</em>” here) with different filled colors. However, it is also possible to add more graphics or symbols as additional layers on the heatmap. There are two arguments <code>cell_fun</code> and <code>layer_fun</code> which both should be user-defined functions.</p>
<div id="cell-fun" class="section level3">
<h3><span class="header-section-number">2.9.1</span> cell_fun</h3>
<p><code>cell_fun</code> draws in each cell repeatedly, which is internally executed in two nested <code>for</code> loops, while <code>layer_fun</code> is the vectorized version of <code>cell_fun</code>. <code>cell_fun</code> is easier to understand but <code>layer_fun</code> is much faster to execute and more customizable.</p>
<p><code>cell_fun</code> expects a function with 7 arguments (the argument names can be different from following, but the order must be the same), which are:</p>
<ul>
<li><code>j</code>: column index in the matrix. Column index corresponds to the x-direction in the viewport, that’s why <code>j</code> is put as the first argument.</li>
<li><code>i</code>: row index in the matrix.</li>
<li><code>x</code>: x coordinate of middle point of the cell which is measured in the viewport of the heatmap body.</li>
<li><code>y</code>: y coordinate of middle point of the cell which is measured in the viewport of the heatmap body.</li>
<li><code>width</code>: width of the cell. The value is <code>unit(1/ncol(sub_mat), &quot;npc&quot;)</code> where <code>sub_mat</code> correspond to the sub-matrix by row splitting and column splitting.</li>
<li><code>height</code>: height of the cell. The value is <code>unit(1/nrow(sub_mat), &quot;npc&quot;)</code>.</li>
<li><code>fill</code>: color of the cell.</li>
</ul>
<p>The values for the seven arguments are automatically sent to the function when executed in each cell.</p>
<p>The most common use is to add values in the matrix onto the heatmap:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">small_mat =<span class="st"> </span>mat[<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">9</span>]
col_fun =<span class="st"> </span><span class="kw">colorRamp2</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="st">&quot;green&quot;</span>, <span class="st">&quot;white&quot;</span>, <span class="st">&quot;red&quot;</span>))
<span class="kw">Heatmap</span>(small_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun,
    <span class="dt">cell_fun =</span> <span class="cf">function</span>(j, i, x, y, width, height, fill) {
        <span class="kw">grid.text</span>(<span class="kw">sprintf</span>(<span class="st">&quot;%.1f&quot;</span>, small_mat[i, j]), x, y, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fontsize =</span> <span class="dv">10</span>))
})</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-64-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>and we can also choose only to add text for the cells with positive values:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(small_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>,  <span class="dt">col =</span> col_fun,
    <span class="dt">cell_fun =</span> <span class="cf">function</span>(j, i, x, y, width, height, fill) {
        <span class="cf">if</span>(small_mat[i, j] <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)
            <span class="kw">grid.text</span>(<span class="kw">sprintf</span>(<span class="st">&quot;%.1f&quot;</span>, small_mat[i, j]), x, y, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fontsize =</span> <span class="dv">10</span>))
})</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-65-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>You can split the heatmap without doing anything extra to <code>cell_fun</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(small_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun,
    <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">2</span>,
    <span class="dt">cell_fun =</span> <span class="cf">function</span>(j, i, x, y, width, height, fill) {
        <span class="kw">grid.text</span>(<span class="kw">sprintf</span>(<span class="st">&quot;%.1f&quot;</span>, small_mat[i, j]), x, y, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fontsize =</span> <span class="dv">10</span>))
})</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-66-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>In following example, we make a heatmap which shows correlation matrix similar as the <strong>corrplot</strong> package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cor_mat =<span class="st"> </span><span class="kw">cor</span>(small_mat)
od =<span class="st"> </span><span class="kw">hclust</span>(<span class="kw">dist</span>(cor_mat))<span class="op">$</span>order
cor_mat =<span class="st"> </span>cor_mat[od, od]
nm =<span class="st"> </span><span class="kw">rownames</span>(cor_mat)
col_fun =<span class="st"> </span>circlize<span class="op">::</span><span class="kw">colorRamp2</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="st">&quot;green&quot;</span>, <span class="st">&quot;white&quot;</span>, <span class="st">&quot;red&quot;</span>))
<span class="co"># `col = col_fun` here is used to generate the legend</span>
<span class="kw">Heatmap</span>(cor_mat, <span class="dt">name =</span> <span class="st">&quot;correlation&quot;</span>, <span class="dt">col =</span> col_fun, <span class="dt">rect_gp =</span> <span class="kw">gpar</span>(<span class="dt">type =</span> <span class="st">&quot;none&quot;</span>), 
    <span class="dt">cell_fun =</span> <span class="cf">function</span>(j, i, x, y, width, height, fill) {
        <span class="kw">grid.rect</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y, <span class="dt">width =</span> width, <span class="dt">height =</span> height, 
            <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">col =</span> <span class="st">&quot;grey&quot;</span>, <span class="dt">fill =</span> <span class="ot">NA</span>))
        <span class="cf">if</span>(i <span class="op">==</span><span class="st"> </span>j) {
            <span class="kw">grid.text</span>(nm[i], <span class="dt">x =</span> x, <span class="dt">y =</span> y)
        } <span class="cf">else</span> <span class="cf">if</span>(i <span class="op">&gt;</span><span class="st"> </span>j) {
            <span class="kw">grid.circle</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y, <span class="dt">r =</span> <span class="kw">abs</span>(cor_mat[i, j])<span class="op">/</span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">min</span>(<span class="kw">unit.c</span>(width, height)), 
                <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fill =</span> <span class="kw">col_fun</span>(cor_mat[i, j]), <span class="dt">col =</span> <span class="ot">NA</span>))
        } <span class="cf">else</span> {
            <span class="kw">grid.text</span>(<span class="kw">sprintf</span>(<span class="st">&quot;%.1f&quot;</span>, cor_mat[i, j]), x, y, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fontsize =</span> <span class="dv">10</span>))
        }
    }, <span class="dt">cluster_rows =</span> <span class="ot">FALSE</span>, <span class="dt">cluster_columns =</span> <span class="ot">FALSE</span>,
    <span class="dt">show_row_names =</span> <span class="ot">FALSE</span>, <span class="dt">show_column_names =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/cell_fun-1.png" width="624" style="display: block; margin: auto;" /></p>
<p>As you may see in previous plot, when setting the non-standard parameter <code>rect_gp = gpar(type = &quot;none&quot;)</code>, the clustering is performed but nothing is drawn on the heatmap body.</p>
<p>One last example is to visualize a <a href="https://en.wikipedia.org/wiki/Go_%28game%29">GO game</a>. The input data takes records of moves in the game.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">str =<span class="st"> &quot;B[cp];W[pq];B[dc];W[qd];B[eq];W[od];B[de];W[jc];B[qk];W[qn]</span>
<span class="st">;B[qh];W[ck];B[ci];W[cn];B[hc];W[je];B[jq];W[df];B[ee];W[cf]</span>
<span class="st">;B[ei];W[bc];B[ce];W[be];B[bd];W[cd];B[bf];W[ad];B[bg];W[cc]</span>
<span class="st">;B[eb];W[db];B[ec];W[lq];B[nq];W[jp];B[iq];W[kq];B[pp];W[op]</span>
<span class="st">;B[po];W[oq];B[rp];W[ql];B[oo];W[no];B[pl];W[pm];B[np];W[qq]</span>
<span class="st">;B[om];W[ol];B[pk];W[qp];B[on];W[rm];B[mo];W[nr];B[rl];W[rk]</span>
<span class="st">;B[qm];W[dp];B[dq];W[ql];B[or];W[mp];B[nn];W[mq];B[qm];W[bp]</span>
<span class="st">;B[co];W[ql];B[no];W[pr];B[qm];W[dd];B[pn];W[ed];B[bo];W[eg]</span>
<span class="st">;B[ef];W[dg];B[ge];W[gh];B[gf];W[gg];B[ek];W[ig];B[fd];W[en]</span>
<span class="st">;B[bn];W[ip];B[dm];W[ff];B[cb];W[fe];B[hp];W[ho];B[hq];W[el]</span>
<span class="st">;B[dl];W[fk];B[ej];W[fp];B[go];W[hn];B[fo];W[em];B[dn];W[eo]</span>
<span class="st">;B[gp];W[ib];B[gc];W[pg];B[qg];W[ng];B[qc];W[re];B[pf];W[of]</span>
<span class="st">;B[rc];W[ob];B[ph];W[qo];B[rn];W[mi];B[og];W[oe];B[qe];W[rd]</span>
<span class="st">;B[rf];W[pd];B[gm];W[gl];B[fm];W[fl];B[lj];W[mj];B[lk];W[ro]</span>
<span class="st">;B[hl];W[hk];B[ik];W[dk];B[bi];W[di];B[dj];W[dh];B[hj];W[gj]</span>
<span class="st">;B[li];W[lh];B[kh];W[lg];B[jn];W[do];B[cl];W[ij];B[gk];W[bl]</span>
<span class="st">;B[cm];W[hk];B[jk];W[lo];B[hi];W[hm];B[gk];W[bm];B[cn];W[hk]</span>
<span class="st">;B[il];W[cq];B[bq];W[ii];B[sm];W[jo];B[kn];W[fq];B[ep];W[cj]</span>
<span class="st">;B[bk];W[er];B[cr];W[gr];B[gk];W[fj];B[ko];W[kp];B[hr];W[jr]</span>
<span class="st">;B[nh];W[mh];B[mk];W[bb];B[da];W[jh];B[ic];W[id];B[hb];W[jb]</span>
<span class="st">;B[oj];W[fn];B[fs];W[fr];B[gs];W[es];B[hs];W[gn];B[kr];W[is]</span>
<span class="st">;B[dr];W[fi];B[bj];W[hd];B[gd];W[ln];B[lm];W[oi];B[oh];W[ni]</span>
<span class="st">;B[pi];W[ki];B[kj];W[ji];B[so];W[rq];B[if];W[jf];B[hh];W[hf]</span>
<span class="st">;B[he];W[ie];B[hg];W[ba];B[ca];W[sp];B[im];W[sn];B[rm];W[pe]</span>
<span class="st">;B[qf];W[if];B[hk];W[nj];B[nk];W[lr];B[mn];W[af];B[ag];W[ch]</span>
<span class="st">;B[bh];W[lp];B[ia];W[ja];B[ha];W[sf];B[sg];W[se];B[eh];W[fh]</span>
<span class="st">;B[in];W[ih];B[ae];W[so];B[af]&quot;</span></code></pre></div>
<p>We convert it into a matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">str =<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">n&quot;</span>, <span class="st">&quot;&quot;</span>, str)
step =<span class="st"> </span><span class="kw">strsplit</span>(str, <span class="st">&quot;;&quot;</span>)[[<span class="dv">1</span>]]
type =<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;(B|W).*&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1&quot;</span>, step)
row =<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;(B|W)</span><span class="ch">\\</span><span class="st">[(.).</span><span class="ch">\\</span><span class="st">]&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">2&quot;</span>, step)
column =<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;(B|W)</span><span class="ch">\\</span><span class="st">[.(.)</span><span class="ch">\\</span><span class="st">]&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">2&quot;</span>, step)

go_mat =<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">nrow =</span> <span class="dv">19</span>, <span class="dt">ncol =</span> <span class="dv">19</span>)
<span class="kw">rownames</span>(go_mat) =<span class="st"> </span>letters[<span class="dv">1</span><span class="op">:</span><span class="dv">19</span>]
<span class="kw">colnames</span>(go_mat) =<span class="st"> </span>letters[<span class="dv">1</span><span class="op">:</span><span class="dv">19</span>]
<span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(row)) {
    go_mat[row[i], column[i]] =<span class="st"> </span>type[i]
}
go_mat[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>]</code></pre></div>
<pre><code>##   a   b   c   d  
## a NA  NA  NA  &quot;W&quot;
## b &quot;W&quot; &quot;W&quot; &quot;W&quot; &quot;B&quot;
## c &quot;B&quot; &quot;B&quot; &quot;W&quot; &quot;W&quot;
## d &quot;B&quot; &quot;W&quot; &quot;B&quot; &quot;W&quot;</code></pre>
<p>Black and white stones are put based on the values in the matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(go_mat, <span class="dt">name =</span> <span class="st">&quot;go&quot;</span>, <span class="dt">rect_gp =</span> <span class="kw">gpar</span>(<span class="dt">type =</span> <span class="st">&quot;none&quot;</span>),
    <span class="dt">cell_fun =</span> <span class="cf">function</span>(j, i, x, y, w, h, col) {
        <span class="kw">grid.rect</span>(x, y, w, h, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fill =</span> <span class="st">&quot;#dcb35c&quot;</span>, <span class="dt">col =</span> <span class="ot">NA</span>))
        <span class="cf">if</span>(i <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) {
            <span class="kw">grid.segments</span>(x, y<span class="op">-</span>h<span class="op">*</span><span class="fl">0.5</span>, x, y)
        } <span class="cf">else</span> <span class="cf">if</span>(i <span class="op">==</span><span class="st"> </span><span class="kw">nrow</span>(go_mat)) {
            <span class="kw">grid.segments</span>(x, y, x, y<span class="op">+</span>h<span class="op">*</span><span class="fl">0.5</span>)
        } <span class="cf">else</span> {
            <span class="kw">grid.segments</span>(x, y<span class="op">-</span>h<span class="op">*</span><span class="fl">0.5</span>, x, y<span class="op">+</span>h<span class="op">*</span><span class="fl">0.5</span>)
        }
        <span class="cf">if</span>(j <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) {
            <span class="kw">grid.segments</span>(x, y, x<span class="op">+</span>w<span class="op">*</span><span class="fl">0.5</span>, y)        
        } <span class="cf">else</span> <span class="cf">if</span>(j <span class="op">==</span><span class="st"> </span><span class="kw">ncol</span>(go_mat)) {
            <span class="kw">grid.segments</span>(x<span class="op">-</span>w<span class="op">*</span><span class="fl">0.5</span>, y, x, y)
        } <span class="cf">else</span> {
            <span class="kw">grid.segments</span>(x<span class="op">-</span>w<span class="op">*</span><span class="fl">0.5</span>, y, x<span class="op">+</span>w<span class="op">*</span><span class="fl">0.5</span>, y)
        }

        <span class="cf">if</span>(i <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">10</span>, <span class="dv">16</span>) <span class="op">&amp;</span><span class="st"> </span>j <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">10</span>, <span class="dv">16</span>)) {
            <span class="kw">grid.points</span>(x, y, <span class="dt">pch =</span> <span class="dv">16</span>, <span class="dt">size =</span> <span class="kw">unit</span>(<span class="dv">2</span>, <span class="st">&quot;mm&quot;</span>))
        }
                
        r =<span class="st"> </span><span class="kw">min</span>(<span class="kw">unit.c</span>(w, h))<span class="op">*</span><span class="fl">0.45</span>
        <span class="cf">if</span>(<span class="kw">is.na</span>(go_mat[i, j])) {
        } <span class="cf">else</span> <span class="cf">if</span>(go_mat[i, j] <span class="op">==</span><span class="st"> &quot;W&quot;</span>) {
            <span class="kw">grid.circle</span>(x, y, r, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fill =</span> <span class="st">&quot;white&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;white&quot;</span>))
        } <span class="cf">else</span> <span class="cf">if</span>(go_mat[i, j] <span class="op">==</span><span class="st"> &quot;B&quot;</span>) {
            <span class="kw">grid.circle</span>(x, y, r, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fill =</span> <span class="st">&quot;black&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;black&quot;</span>))
        }
    },
    <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;B&quot;</span> =<span class="st"> &quot;black&quot;</span>, <span class="st">&quot;W&quot;</span> =<span class="st"> &quot;white&quot;</span>),
    <span class="dt">show_row_names =</span> <span class="ot">FALSE</span>, <span class="dt">show_column_names =</span> <span class="ot">FALSE</span>,
    <span class="dt">column_title =</span> <span class="st">&quot;One famous GO game&quot;</span>,
    <span class="dt">heatmap_legend_param =</span> <span class="kw">list</span>(<span class="dt">title =</span> <span class="st">&quot;Player&quot;</span>, <span class="dt">at =</span> <span class="kw">c</span>(<span class="st">&quot;B&quot;</span>, <span class="st">&quot;W&quot;</span>), 
        <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;player1&quot;</span>, <span class="st">&quot;player2&quot;</span>), <span class="dt">border =</span> <span class="st">&quot;black&quot;</span>)
)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-69-1.png" width="576" style="display: block; margin: auto;" /></p>
</div>
<div id="layer-fun" class="section level3">
<h3><span class="header-section-number">2.9.2</span> layer_fun</h3>
<p><code>cell_fun</code> adds graphics cell by cell, while <code>layer_fun</code> adds graphics in a block-wise manner. Similar as <code>cell_fun</code>, <code>layer_fun</code> also needs seven arguments, but they are all in vector form (<code>layer_fun</code> can also have a eighth and ninth arguments which is introduced later this section):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># code only for demonstration</span>
<span class="kw">Heatmap</span>(..., <span class="dt">layer_fun =</span> <span class="cf">function</span>(j, i, x, y, w, h, fill) {...})
<span class="co"># on you can capitalize the arguments to mark they are vectors</span>
<span class="kw">Heatmap</span>(..., <span class="dt">layer_fun =</span> <span class="cf">function</span>(J, I, X, Y, W, H, F) {...})</code></pre></div>
<p><code>j</code> and <code>i</code> still contain the column and row indices corresponding to the original matrix, but since now <code>layer_fun</code> applies to a block of cells (or a block of heatmap if the heatmap is split), <code>j</code> and <code>i</code> are vectors for all the cells in the current heatmap slice. Similarlly, <code>x</code>, <code>y</code>, <code>w</code>, <code>h</code> and <code>fill</code> are all vectors corresponding to all cells in the current heatmap slice.</p>
<p>Since <code>j</code> and <code>i</code> now are vectors, to get corresponding values in the matrix, we cannot use the form as <code>mat[j, i]</code> because it gives you a sub-matrix with <code>length(i)</code> rows and <code>length(j)</code> columns. Instead we can use <code>pindex()</code> function from <strong>ComplexHeatmap</strong> which is like pairwise indexing for a matrix. See follow example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mfoo =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>, <span class="dt">nr =</span> <span class="dv">3</span>)
mfoo[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>)]</code></pre></div>
<pre><code>##      [,1] [,2]
## [1,]    1    7
## [2,]    2    8</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># but we actually want mfoo[1, 1] and mfoo[2, 3]</span>
<span class="kw">pindex</span>(mfoo, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))</code></pre></div>
<pre><code>## [1] 1 8</code></pre>
<p>Next example shows the <code>layer_fun</code> version of adding text on heatmap. It’s basically the same as the <code>cell_fun</code> version.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">col_fun =<span class="st"> </span><span class="kw">colorRamp2</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="st">&quot;green&quot;</span>, <span class="st">&quot;white&quot;</span>, <span class="st">&quot;red&quot;</span>))
<span class="kw">Heatmap</span>(small_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun,
    <span class="dt">layer_fun =</span> <span class="cf">function</span>(j, i, x, y, width, height, fill) {
        <span class="co"># since grid.text can also be vectorized</span>
        <span class="kw">grid.text</span>(<span class="kw">sprintf</span>(<span class="st">&quot;%.1f&quot;</span>, <span class="kw">pindex</span>(small_mat, i, j)), x, y, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fontsize =</span> <span class="dv">10</span>))
})</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-72-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>And only add text to cells with positive values:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(small_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun, 
    <span class="dt">layer_fun =</span> <span class="cf">function</span>(j, i, x, y, width, height, fill) {
        v =<span class="st"> </span><span class="kw">pindex</span>(small_mat, i, j)
        l =<span class="st"> </span>v <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>
        <span class="kw">grid.text</span>(<span class="kw">sprintf</span>(<span class="st">&quot;%.1f&quot;</span>, v[l]), x[l], y[l], <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fontsize =</span> <span class="dv">10</span>))
})</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-73-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>When the heatmap is split, <code>layer_fun</code> is applied in every slice.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(small_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun,
    <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">2</span>,
    <span class="dt">layer_fun =</span> <span class="cf">function</span>(j, i, x, y, width, height, fill) {
        v =<span class="st"> </span><span class="kw">pindex</span>(small_mat, i, j)
        <span class="kw">grid.text</span>(<span class="kw">sprintf</span>(<span class="st">&quot;%.1f&quot;</span>, v), x, y, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fontsize =</span> <span class="dv">10</span>))
        <span class="cf">if</span>(<span class="kw">sum</span>(v <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)<span class="op">/</span><span class="kw">length</span>(v) <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.75</span>) {
            <span class="kw">grid.rect</span>(<span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">lwd =</span> <span class="dv">2</span>, <span class="dt">fill =</span> <span class="st">&quot;transparent&quot;</span>))
        }
})</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-74-1.png" width="480" style="display: block; margin: auto;" /></p>
<p><code>layer_fun</code> can also have two more arguments which are the index for the current row slice and column slice. E.g. we want to add borders for the top right and bottom left slices.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(small_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun,
    <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">2</span>,
    <span class="dt">layer_fun =</span> <span class="cf">function</span>(j, i, x, y, width, height, fill, slice_r, slice_c) {
        v =<span class="st"> </span><span class="kw">pindex</span>(small_mat, i, j)
        <span class="kw">grid.text</span>(<span class="kw">sprintf</span>(<span class="st">&quot;%.1f&quot;</span>, v), x, y, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">fontsize =</span> <span class="dv">10</span>))
        <span class="cf">if</span>(slice_r <span class="op">!=</span><span class="st"> </span>slice_c) {
            <span class="kw">grid.rect</span>(<span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">lwd =</span> <span class="dv">2</span>, <span class="dt">fill =</span> <span class="st">&quot;transparent&quot;</span>))
        }
})</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-75-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>The advantage of <code>lay_fun</code> is it is not only fast to add graphics, but also it provides more possibilities to customize the heatmap. Consider following visualization: For each row in the heatmap, if values in the neighbouring two columns have the same sign, we add a red line or a green line depending on the sign of the two values. (Don’t be frightened by following code. They are explained after the code.)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(small_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun,
    <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">2</span>,
    <span class="dt">layer_fun =</span> <span class="cf">function</span>(j, i, x, y, w, h, fill) {
        <span class="co"># restore_matrix() is explained after this chunk of code</span>
        ind_mat =<span class="st"> </span><span class="kw">restore_matrix</span>(j, i, x, y)
        <span class="cf">for</span>(ir <span class="cf">in</span> <span class="kw">seq_len</span>(<span class="kw">nrow</span>(ind_mat))) {
            <span class="co"># start from the second column</span>
            <span class="cf">for</span>(ic <span class="cf">in</span> <span class="kw">seq_len</span>(<span class="kw">ncol</span>(ind_mat))[<span class="op">-</span><span class="dv">1</span>]) {
                ind1 =<span class="st"> </span>ind_mat[ir, ic<span class="op">-</span><span class="dv">1</span>] <span class="co"># previous column</span>
                ind2 =<span class="st"> </span>ind_mat[ir, ic]   <span class="co"># current column</span>
                v1 =<span class="st"> </span>small_mat[i[ind1], j[ind1]]
                v2 =<span class="st"> </span>small_mat[i[ind2], j[ind2]]
                <span class="cf">if</span>(v1 <span class="op">*</span><span class="st"> </span>v2 <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) { <span class="co"># if they have the same sign</span>
                    col =<span class="st"> </span><span class="kw">ifelse</span>(v1 <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>, <span class="st">&quot;darkred&quot;</span>, <span class="st">&quot;darkgreen&quot;</span>)
                    <span class="kw">grid.segments</span>(x[ind1], y[ind1], x[ind2], y[ind2],
                        <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">col =</span> col, <span class="dt">lwd =</span> <span class="dv">2</span>))
                    <span class="kw">grid.points</span>(x[<span class="kw">c</span>(ind1, ind2)], y[<span class="kw">c</span>(ind1, ind2)], 
                        <span class="dt">pch =</span> <span class="dv">16</span>, <span class="dt">gp =</span> <span class="kw">gpar</span>(<span class="dt">col =</span> col), <span class="dt">size =</span> <span class="kw">unit</span>(<span class="dv">4</span>, <span class="st">&quot;mm&quot;</span>))
                }
            }
        }
    }
)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-76-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>The values that are sent to <code>layer_fun</code> are all vectors (for the vectorization of the <strong>grid</strong> graphic functions), however, the heatmap slice where <code>layer_fun</code> is applied to, is still represented by a matrix, thus, it would be very convinient if all the arguments in <code>layer_fun</code> can be converted to the sub-matrix for the current slice. Here, as shown in above example, <code>restore_matrix()</code> does the job. <code>restore_matrix()</code> directly accepts the first four argument in <code>layer_fun</code> and returns an index matrix, where rows and columns correspond to the rows and columns in the current slice, from top to bottom and from left to right. The values in the matrix are the natural order of e.g. vector <code>j</code> in current slice.</p>
<p>If you run following code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(small_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun,
    <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">2</span>,
    <span class="dt">layer_fun =</span> <span class="cf">function</span>(j, i, x, y, w, h, fill) {
        ind_mat =<span class="st"> </span><span class="kw">restore_matrix</span>(j, i, x, y)
        <span class="kw">print</span>(ind_mat)
    }
)</code></pre></div>
<p>The first output which is for the top-left slice:</p>
<pre><code>     [,1] [,2] [,3] [,4] [,5]
[1,]    1    4    7   10   13
[2,]    2    5    8   11   14
[3,]    3    6    9   12   15</code></pre>
<p>As you see, this is a three-row and five-column index matrix where the first row corresponds to the top row in the slice. The values in the matrix correspond to the natural index (i.e. 1, 2, …) in <code>j</code>, <code>i</code>, <code>x</code>, <code>y</code>, … in <code>layer_fun</code>. Now, if we want to add values on the second column in the top-left slice, the code which is put inside <code>layer_fun</code> would look like:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span>(ind <span class="cf">in</span> ind_mat[, <span class="dv">2</span>]) {
    <span class="kw">grid.text</span>(small_mat[i[ind], j[ind]], x[ind], y[ind], ...)
}</code></pre></div>
<p>Now it is easier to understand the second example: we want to add points to the second row and the third column in every slice:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(small_mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">col =</span> col_fun,
    <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">2</span>,
    <span class="dt">layer_fun =</span> <span class="cf">function</span>(j, i, x, y, w, h, fill) {
        ind_mat =<span class="st"> </span><span class="kw">restore_matrix</span>(j, i, x, y)
        ind =<span class="st"> </span><span class="kw">unique</span>(<span class="kw">c</span>(ind_mat[<span class="dv">2</span>, ], ind_mat[, <span class="dv">3</span>]))
        <span class="kw">grid.points</span>(x[ind], y[ind], <span class="dt">pch =</span> <span class="dv">16</span>, <span class="dt">size =</span> <span class="kw">unit</span>(<span class="dv">4</span>, <span class="st">&quot;mm&quot;</span>))
    }
)</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-79-1.png" width="480" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="size-of-the-heatmap" class="section level2">
<h2><span class="header-section-number">2.10</span> Size of the heatmap</h2>
<p><code>width</code>, <code>heatmap_width</code>, <code>height</code> and <code>heatmap_height</code> control the size of the heatmap. By default, all heatmap components have fixed width or height, e.g. the width of row dendrogram is <code>1cm</code>. The width or the height of the heatmap body fill the rest area of the final plotting region, which means, if you draw it in an interactive graphic window and you change the size of the window by draging it, the size of the heatmap body is automatically adjusted.</p>
<p><code>heatmap_width</code> and <code>heatmap_height</code> control the width/height of the complete heatmap including all heatmap components (excluding the legends) while <code>width</code> and <code>height</code> only control the width/height of the heamtap body. All these four arguments can be set as absolute units.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">width =</span> <span class="kw">unit</span>(<span class="dv">8</span>, <span class="st">&quot;cm&quot;</span>), <span class="dt">height =</span> <span class="kw">unit</span>(<span class="dv">8</span>, <span class="st">&quot;cm&quot;</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-80-1.png" width="480" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">heatmap_width =</span> <span class="kw">unit</span>(<span class="dv">8</span>, <span class="st">&quot;cm&quot;</span>), <span class="dt">heatmap_height =</span> <span class="kw">unit</span>(<span class="dv">8</span>, <span class="st">&quot;cm&quot;</span>))</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-80-2.png" width="480" style="display: block; margin: auto;" /></p>
<p>These four arguments are more important when adjust the size in a list of heatmaps (see Section <a href="a-list-of-heatmaps.html#size-of-heatmaps">4.2</a>).</p>
<p>When the size of the heatmap is set as absolute units, it is possible that the size of the figure is larger than the size of the plot, which gives blank areas around the plot. The size of the heatmap can be retrieved by <code>width()</code> and <code>height()</code> functions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ht =<span class="st"> </span><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">width =</span> <span class="kw">unit</span>(<span class="dv">8</span>, <span class="st">&quot;cm&quot;</span>), <span class="dt">height =</span> <span class="kw">unit</span>(<span class="dv">8</span>, <span class="st">&quot;cm&quot;</span>))
ht =<span class="st"> </span><span class="kw">draw</span>(ht)
ComplexHeatmap<span class="op">:::</span><span class="kw">width</span>(ht)</code></pre></div>
<pre><code>## [1] 118.985533333333mm</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ComplexHeatmap<span class="op">:::</span><span class="kw">height</span>(ht)</code></pre></div>
<pre><code>## [1] 114.8515mm</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ht =<span class="st"> </span><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">heatmap_width =</span> <span class="kw">unit</span>(<span class="dv">8</span>, <span class="st">&quot;cm&quot;</span>), 
    <span class="dt">heatmap_height =</span> <span class="kw">unit</span>(<span class="dv">8</span>, <span class="st">&quot;cm&quot;</span>))
ht =<span class="st"> </span><span class="kw">draw</span>(ht)
ComplexHeatmap<span class="op">:::</span><span class="kw">width</span>(ht)</code></pre></div>
<pre><code>## [1] 95.0216666666667mm</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ComplexHeatmap<span class="op">:::</span><span class="kw">height</span>(ht)</code></pre></div>
<pre><code>## [1] 84mm</code></pre>
</div>
<div id="plot-the-heatmap" class="section level2">
<h2><span class="header-section-number">2.11</span> Plot the heatmap</h2>
<p><code>Heatmap()</code> function actually is only a constructor, which means it only puts all the data and configurations into the object in the <code>Heatmap</code> class. The clustering will only be performed when the <code>draw()</code> method is called. Under interactive mode (e.g. the interactive R terminal where you can type your R code line by line), directly calling <code>Heatmap()</code> without returning to any object prints the object and the print method (or the S4 <code>show()</code> method) for the <code>Heatmap</code> class object calls <code>draw()</code> internally. So if you type <code>Heatmap(...)</code> in your R terminal, it looks like it is a plotting function like <code>plot()</code>, you need to be aware of that it is actually not true and in the following cases you might see nothing plotted.</p>
<ul>
<li>you put <code>Heatmap(...)</code> inside a function,</li>
<li>you put <code>Heatmap(...)</code> in a code chunk like <code>for</code> or <code>if-else</code></li>
<li>you put <code>Heatmap(...)</code> in an Rscript and you run it under command line.</li>
</ul>
<p>The reason is in above three cases, the <code>show()</code> method WILL NOT be called and thus <code>draw()</code> method is not executed either. So, to make the plot, you need to call <code>draw()</code> explicitly: <code>draw(Heatmap(...))</code> or:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># code only for demonstration</span>
ht =<span class="st"> </span><span class="kw">Heatmap</span>(...)
<span class="kw">draw</span>(ht)</code></pre></div>
<p>The <code>draw()</code> function actually is applied to a list of heatmaps in <code>HeatmapList</code> class. The <code>draw()</code> method for the single <code>Heatmap</code> class constructs a <code>HeatmapList</code> with only one heatmap and call <code>draw()</code> method of the <code>HeatmapList</code> class. The <code>draw()</code> function accpets a lot of more arguments which e.g. controls the legends. It will be discussed in Chapter <a href="a-list-of-heatmaps.html#a-list-of-heatmaps">4</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">draw</span>(ht, heatmap_legend_side, padding, ...)</code></pre></div>
</div>
<div id="get-orders-and-dendrograms-from-heatmap" class="section level2">
<h2><span class="header-section-number">2.12</span> Get orders and dendrograms</h2>
<p>The row/column orders of the heatmap can be obtained by <code>row_order()</code>/<code>column_order()</code> functions. You can directly apply to the heatmap object returned by <code>Heatmap()</code> or to the object returned by <code>draw()</code>. In following, we take <code>row_order()</code> as example.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">small_mat =<span class="st"> </span>mat[<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">9</span>]
ht1 =<span class="st"> </span><span class="kw">Heatmap</span>(small_mat)
<span class="kw">row_order</span>(ht1)</code></pre></div>
<pre><code>## [1] 9 6 7 8 3 4 1 2 5</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ht2 =<span class="st"> </span><span class="kw">draw</span>(ht1)
<span class="kw">row_order</span>(ht2)</code></pre></div>
<pre><code>## [1] 9 6 7 8 3 4 1 2 5</code></pre>
<p>As explained in previous section, <code>Heatmap()</code> function does not perform clustering, thus, when directly apply <code>row_order()</code> on <code>ht1</code>, clustering will be first performed. Later when making the heatmap by <code>draw(ht1)</code>, the clustering will be applied again. This might be a problem that if you set k-means clustering in the heatmap. Since the clustering is applied twice, k-means might give you different clusterings, which means, you might have different results from <code>row_order()</code> and you might have different heatmap.</p>
<p>In following chunk of code, <code>o1</code>, <code>o2</code> and <code>o3</code> might be different because each time, k-means clustering is performed.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># code only for demonstration</span>
ht1 =<span class="st"> </span><span class="kw">Heatmap</span>(small_mat, <span class="dt">row_km =</span> <span class="dv">2</span>)
o1 =<span class="st"> </span><span class="kw">row_order</span>(ht1)
o2 =<span class="st"> </span><span class="kw">row_order</span>(ht1)
ht2 =<span class="st"> </span><span class="kw">draw</span>(ht1)
o3 =<span class="st"> </span><span class="kw">row_order</span>(ht2)
o4 =<span class="st"> </span><span class="kw">row_order</span>(ht2)</code></pre></div>
<p><code>draw()</code> function returns the heatmap (or more precisely, the heatmap list) which has already been reordered, and applying <code>row_order()</code> just extracts the row order from the object, which ensures the row order is exactly the same as the one shown in the heatmap. In above code, <code>o3</code> is always identical to <code>o4</code>.</p>
<p>So, the preferable way to get row/column orders is as follows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># code only for demonstration</span>
ht =<span class="st"> </span><span class="kw">Heatmap</span>(small_mat)
ht =<span class="st"> </span><span class="kw">draw</span>(ht)
<span class="kw">row_order</span>(ht)
<span class="kw">column_order</span>(ht)</code></pre></div>
<p>If rows/columns are split, row order or column order will be a list.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ht =<span class="st"> </span><span class="kw">Heatmap</span>(small_mat, <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">3</span>)
ht =<span class="st"> </span><span class="kw">draw</span>(ht)
<span class="kw">row_order</span>(ht)</code></pre></div>
<pre><code>## $`1`
## [1] 1 2 5
## 
## $`2`
## [1] 9 6 7 8 3 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">column_order</span>(ht)</code></pre></div>
<pre><code>## $`1`
## [1] 5 9
## 
## $`2`
## [1] 2 7 6
## 
## $`3`
## [1] 8 1 3 4</code></pre>
<p>Similarly, the <code>row_dend()</code>/<code>column_dend()</code> functions return the dendrograms. It returns a single dendrogram or a list of dendrograms depending on whether the heatmap is split.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ht =<span class="st"> </span><span class="kw">Heatmap</span>(small_mat, <span class="dt">row_km =</span> <span class="dv">2</span>)
ht =<span class="st"> </span><span class="kw">draw</span>(ht)
<span class="kw">row_dend</span>(ht)</code></pre></div>
<pre><code>## $`1`
## &#39;dendrogram&#39; with 2 branches and 3 members total, at height 2.718561 
## 
## $`2`
## &#39;dendrogram&#39; with 2 branches and 6 members total, at height 3.109169</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">column_dend</span>(ht)</code></pre></div>
<pre><code>## &#39;dendrogram&#39; with 2 branches and 9 members total, at height 5.191887</code></pre>
<p><code>row_order()</code>, <code>column_order()</code>, <code>row_dend()</code> and <code>column_dend()</code> also work for a list of heatmaps, it will be introduced in Section <a href="a-list-of-heatmaps.html#get-orders-and-dendrograms-from-a-list-of-heatmaps">4.12</a>.</p>
</div>
<div id="subset-a-heatmap" class="section level2">
<h2><span class="header-section-number">2.13</span> Subset a heatmap</h2>
<p>Since heatmap is a representation of a matrix, there is also a subset method for the <code>Heatmap</code> class.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ht =<span class="st"> </span><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>)
<span class="kw">dim</span>(ht)</code></pre></div>
<pre><code>## [1] 18 24</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ht[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>]</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-89-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>The annotations are subsetted accordingly as well.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ht =<span class="st"> </span><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_km =</span> <span class="dv">2</span>, <span class="dt">column_km =</span> <span class="dv">3</span>,
    <span class="dt">col =</span> <span class="kw">colorRamp2</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="st">&quot;green&quot;</span>, <span class="st">&quot;white&quot;</span>, <span class="st">&quot;red&quot;</span>)),
    <span class="dt">top_annotation =</span> <span class="kw">HeatmapAnnotation</span>(<span class="dt">foo1 =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">24</span>, <span class="dt">bar1 =</span> <span class="kw">anno_points</span>(<span class="kw">runif</span>(<span class="dv">24</span>))),
    <span class="dt">right_annotation =</span> <span class="kw">rowAnnotation</span>(<span class="dt">foo2 =</span> <span class="dv">18</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">bar2 =</span> <span class="kw">anno_barplot</span>(<span class="kw">runif</span>(<span class="dv">18</span>)))
)
ht[<span class="dv">1</span><span class="op">:</span><span class="dv">9</span><span class="op">*</span><span class="dv">2</span> <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">12</span><span class="op">*</span><span class="dv">2</span>] <span class="co"># odd rows, even columns</span></code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-90-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>The heatmap components are subsetted if they are vector-like. Some configurations in the heatmap keep the same when subsetting, e.g. if <code>row_km</code> is set in the original heatmap, the configuration of k-means is kept and it is performed in the sub-heatmap. So in following example, k-means clustering is only performed when making heatmap for <code>ht2</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ht =<span class="st"> </span><span class="kw">Heatmap</span>(mat, <span class="dt">name =</span> <span class="st">&quot;mat&quot;</span>, <span class="dt">row_km =</span> <span class="dv">2</span>)
ht2 =<span class="st"> </span>ht[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>]
ht2</code></pre></div>
<p><img src="02-single_heatmap_files/figure-html/unnamed-chunk-91-1.png" width="480" style="display: block; margin: auto;" /></p>
<p><strong>The implementation of subsetting heatmaps is very experimental.</strong> It is not always working, e.g. if <code>cell_fun</code> is defined and uses an external matrix, or clustering objects are assigned to <code>cluster_rows</code> or <code>cluster_columns</code>.</p>
<p>There are also subset methods for the <code>HeatmapAnnotation</code> class (Section <a href="heatmap-annotations.html#heatmap-annotation-utility-function">3.19</a>) and the <code>HeatmapList</code> class (Section <a href="a-list-of-heatmaps.html#subset-heatmap-list">4.10</a>), but both are very experimental as well.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="introduction.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="heatmap-annotations.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/jokergoo/ComplexHeatmap-reference/edit/master/02-single_heatmap.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"download": ["ComplexHeatmap-reference.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
